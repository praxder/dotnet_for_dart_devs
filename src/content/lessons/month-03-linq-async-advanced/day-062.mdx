---
title: "Operator Overloading and Conversions"
day: 62
week: 13
module: 5
moduleName: "Async, Delegates & Advanced C#"
phase: "csharp"
dartConcept: "operator overloading in Dart classes"
csharpConcept: "operator overloading, implicit/explicit conversions, checked operators"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

C# and Dart both support operator overloading with similar syntax. C# adds conversion operators (implicit and explicit) and — in .NET 7+ — generic math through interfaces, enabling a whole new level of numeric abstraction.

## Operator Overloading

<CodeComparison>
  <div slot="dart">
  ```dart
  class Vector {
    final double x, y;
    const Vector(this.x, this.y);

    Vector operator +(Vector other) => Vector(x + other.x, y + other.y);
    Vector operator -(Vector other) => Vector(x - other.x, y - other.y);
    Vector operator *(double scalar) => Vector(x * scalar, y * scalar);
    bool operator ==(Object other) =>
      other is Vector && x == other.x && y == other.y;

    @override
    String toString() => 'Vector($x, $y)';
  }
  ```
  </div>
  <div slot="csharp">
  ```csharp
  public readonly record struct Vector(double X, double Y)
  {
      // Arithmetic operators
      public static Vector operator +(Vector a, Vector b)
          => new(a.X + b.X, a.Y + b.Y);

      public static Vector operator -(Vector a, Vector b)
          => new(a.X - b.X, a.Y - b.Y);

      public static Vector operator *(Vector v, double scalar)
          => new(v.X * scalar, v.Y * scalar);

      public static Vector operator *(double scalar, Vector v)
          => v * scalar;  // commutative — delegate

      public static Vector operator -(Vector v)   // unary negation
          => new(-v.X, -v.Y);

      // record struct provides ==, !=, GetHashCode automatically
      // (equality compares all fields)

      public double Magnitude => Math.Sqrt(X * X + Y * Y);
      public Vector Normalized => this * (1.0 / Magnitude);

      public override string ToString() => $"Vector({X}, {Y})";
  }

  var a = new Vector(1, 2);
  var b = new Vector(3, 4);
  Console.WriteLine(a + b);     // Vector(4, 6)
  Console.WriteLine(a * 3);     // Vector(3, 6)
  Console.WriteLine(3 * a);     // Vector(3, 6)
  Console.WriteLine(-b);        // Vector(-3, -4)
  ```
  </div>
</CodeComparison>

## Comparison Operators

```csharp
public readonly record struct Money(decimal Amount, string Currency)
    : IComparable<Money>
{
    public static bool operator <(Money a, Money b)
    {
        EnsureSameCurrency(a, b);
        return a.Amount < b.Amount;
    }

    public static bool operator >(Money a, Money b) => b < a;
    public static bool operator <=(Money a, Money b) => !(a > b);
    public static bool operator >=(Money a, Money b) => !(a < b);

    public int CompareTo(Money other)
    {
        EnsureSameCurrency(this, other);
        return Amount.CompareTo(other.Amount);
    }

    public static Money operator +(Money a, Money b)
    {
        EnsureSameCurrency(a, b);
        return new Money(a.Amount + b.Amount, a.Currency);
    }

    private static void EnsureSameCurrency(Money a, Money b)
    {
        if (a.Currency != b.Currency)
            throw new InvalidOperationException(
                $"Cannot operate on {a.Currency} and {b.Currency}");
    }
}
```

## Implicit and Explicit Conversions

```csharp
public readonly record struct Celsius(double Value)
{
    // Implicit: no cast needed — safe, no data loss
    public static implicit operator Celsius(double value) => new(value);
    public static implicit operator double(Celsius c) => c.Value;

    // Explicit: cast required — could lose data or fail
    public static explicit operator Fahrenheit(Celsius c)
        => new(c.Value * 9 / 5 + 32);
}

public readonly record struct Fahrenheit(double Value)
{
    public static explicit operator Celsius(Fahrenheit f)
        => new((f.Value - 32) * 5 / 9);
}

// Usage
Celsius boiling = 100.0;          // implicit conversion from double
double temp = boiling;            // implicit conversion to double
Fahrenheit f = (Fahrenheit)boiling; // explicit cast

// Strong ID pattern — common in Domain-Driven Design
public readonly record struct UserId(Guid Value)
{
    public static implicit operator UserId(Guid id) => new(id);
    public static implicit operator Guid(UserId id) => id.Value;
    public static UserId NewId() => new(Guid.NewGuid());
    public override string ToString() => Value.ToString();
}

UserId id = Guid.NewGuid();  // implicit
Guid raw = id;               // implicit
```

<ConceptCallout type="tip" title="When to Use Implicit vs Explicit Conversion">
**Implicit** conversion: use when the conversion is always safe and lossless (e.g., `int` to `long`, `Celsius` from `double`). **Explicit** conversion: use when the conversion might fail or lose precision (e.g., `double` to `int`, temperature conversions with rounding). When in doubt, require explicit — it makes intent clear.
</ConceptCallout>

## Generic Math Interfaces (.NET 7+)

```csharp
// INumber<T> — write truly generic arithmetic
using System.Numerics;

// Works for int, double, decimal, float, short, BigInteger, etc.
T Sum<T>(IEnumerable<T> values) where T : INumber<T>
    => values.Aggregate(T.Zero, (acc, x) => acc + x);

T Average<T>(IEnumerable<T> values) where T : INumber<T>
{
    T sum = T.Zero;
    int count = 0;
    foreach (var v in values) { sum += v; count++; }
    return sum / T.CreateChecked(count);
}

Console.WriteLine(Sum(new[] { 1, 2, 3 }));            // int: 6
Console.WriteLine(Sum(new[] { 1.5, 2.5, 3.0 }));      // double: 7.0
Console.WriteLine(Average(new[] { 1m, 2m, 3m, 4m })); // decimal: 2.5

// Your own type can participate in generic math:
public readonly record struct Money(decimal Amount, string Currency)
    : IAdditionOperators<Money, Money, Money>,
      ISubtractionOperators<Money, Money, Money>
{
    public static Money operator +(Money a, Money b)
        => new(a.Amount + b.Amount, a.Currency);  // simplified

    public static Money operator -(Money a, Money b)
        => new(a.Amount - b.Amount, a.Currency);
}
```

## Checked Operators (.NET 7+)

```csharp
// Checked operators throw on overflow
// Regular operators silently overflow (wrap around)
public readonly record struct SafeInt(int Value)
{
    public static SafeInt operator +(SafeInt a, SafeInt b)
        => checked(new SafeInt(a.Value + b.Value));  // throws OverflowException

    public static SafeInt operator checked +(SafeInt a, SafeInt b)
        => new SafeInt(checked(a.Value + b.Value));

    public static SafeInt operator -(SafeInt a, SafeInt b)
        => new SafeInt(a.Value - b.Value);  // unchecked — wraps around

    public static SafeInt operator checked -(SafeInt a, SafeInt b)
        => new SafeInt(checked(a.Value - b.Value));
}
```

<ExerciseBlock>
1. Implement a `Fraction` struct with `+`, `-`, `*`, `/` operators that returns reduced fractions. Add implicit conversion from `int` and explicit conversion to `double`. Ensure `Fraction(1,3) + Fraction(1,6) == Fraction(1,2)`.
2. Create a `Polynomial` class (representing e.g. `3x² + 2x + 1`) with `+`, `-`, `*` operators and `Evaluate(double x)` method. Use `operator []` to get/set coefficients by degree.
3. Write a generic `Statistics<T>` class using `INumber<T>` constraints that computes `Min`, `Max`, `Sum`, `Mean`, and `Variance` for any numeric type.
</ExerciseBlock>
