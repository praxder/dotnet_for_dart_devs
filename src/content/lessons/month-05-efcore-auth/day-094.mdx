---
title: "Dapper: Multi-Mapping and Relationships"
day: 94
week: 19
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "manual join mapping in sqflite, nested objects from SQL"
csharpConcept: "multi-mapping, splitOn, QueryMultiple, one-to-many with dictionary"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

With EF Core, navigation properties load related data automatically. With Dapper, you write the JOIN and tell Dapper how to split the result row into multiple objects. This gives you exact control over what SQL runs, at the cost of a bit more mapping code.

## Multi-Mapping — JOIN to Nested Objects

```csharp
// The entities:
public class Order
{
    public int Id { get; set; }
    public decimal Total { get; set; }
    public DateTime OrderedAt { get; set; }
    public string Status { get; set; } = "";
    public int CustomerId { get; set; }
    public Customer? Customer { get; set; }  // navigation property — you fill this in
}

public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; } = "";
    public string Email { get; set; } = "";
}

// Multi-mapping: Dapper splits each row into Order + Customer objects
public async Task<IEnumerable<Order>> GetOrdersWithCustomerAsync()
{
    using var conn = Open();

    return await conn.QueryAsync<Order, Customer, Order>(
        sql: @"
            SELECT
                o.id, o.total, o.ordered_at, o.status, o.customer_id,
                c.id, c.name, c.email          -- Customer columns come AFTER
            FROM orders o
            INNER JOIN customers c ON c.id = o.customer_id",
        map: (order, customer) =>
        {
            order.Customer = customer;  // attach the Customer to the Order
            return order;
        },
        splitOn: "id");  // "id" is the first column of the second object (Customer.Id)
        // Dapper splits the row at the column named "id" (second occurrence)
}
```

<ConceptCallout type="tip" title="splitOn — How Dapper Knows Where to Split">
`splitOn` tells Dapper which column marks the start of the next object. In the SELECT above, the first `id` maps to `Order.Id`, and the second `id` (from the customers table) is where Dapper starts mapping `Customer`. Use column aliases when the split column names aren't obvious.
</ConceptCallout>

## Alias Columns for Clarity

```csharp
// Using aliases makes splitOn unambiguous and the SQL self-documenting
public async Task<IEnumerable<Order>> GetOrdersWithCustomerAsync()
{
    using var conn = Open();

    return await conn.QueryAsync<Order, Customer, Order>(@"
        SELECT
            o.id           AS OrderId,
            o.total        AS Total,
            o.ordered_at   AS OrderedAt,
            o.status       AS Status,
            o.customer_id  AS CustomerId,
            c.id           AS CustomerId,   -- splitOn point
            c.name         AS Name,
            c.email        AS Email
        FROM orders o
        INNER JOIN customers c ON c.id = o.customer_id",
        (order, customer) => { order.Customer = customer; return order; },
        splitOn: "CustomerId");  // clearer — splits at the second "CustomerId"
}
```

## Three-Way JOIN — Three Objects

```csharp
public class OrderLine
{
    public int Id { get; set; }
    public int Quantity { get; set; }
    public decimal UnitPrice { get; set; }
    public Product? Product { get; set; }
}

public async Task<IEnumerable<OrderLine>> GetOrderLinesAsync(int orderId)
{
    using var conn = Open();

    return await conn.QueryAsync<OrderLine, Product, OrderLine>(@"
        SELECT
            ol.id, ol.quantity, ol.unit_price,
            p.id, p.name, p.sku
        FROM order_lines ol
        INNER JOIN products p ON p.id = ol.product_id
        WHERE ol.order_id = @OrderId",
        (line, product) => { line.Product = product; return line; },
        new { OrderId = orderId },
        splitOn: "id");  // second "id" = Product.Id
}
```

## One-to-Many — Dictionary Pattern

```csharp
// Problem: ORDER has many LINES
// A JOIN returns duplicate Order rows (one per line)
// Solution: use a dictionary to deduplicate

public class Order
{
    public int Id { get; set; }
    public decimal Total { get; set; }
    public string Status { get; set; } = "";
    public List<OrderLine> Lines { get; set; } = [];
}

public async Task<Order?> GetOrderWithLinesAsync(int orderId)
{
    using var conn = Open();

    var orderDict = new Dictionary<int, Order>();

    await conn.QueryAsync<Order, OrderLine, Order>(@"
        SELECT
            o.id, o.total, o.status,
            ol.id, ol.quantity, ol.unit_price, ol.product_id
        FROM orders o
        LEFT JOIN order_lines ol ON ol.order_id = o.id
        WHERE o.id = @OrderId",
        (order, line) =>
        {
            // Get or create the Order in the dictionary
            if (!orderDict.TryGetValue(order.Id, out var existingOrder))
            {
                existingOrder = order;
                orderDict[order.Id] = existingOrder;
            }

            // Add the line to the deduplicated order
            if (line?.Id > 0)  // LEFT JOIN → line can be null if no lines
                existingOrder.Lines.Add(line);

            return existingOrder;
        },
        new { OrderId = orderId },
        splitOn: "id");

    return orderDict.Values.FirstOrDefault();
}
```

## QueryMultiple — Multiple Result Sets

```csharp
// When you need multiple independent queries in one round trip
// More efficient than multiple separate queries

public async Task<(Order? Order, IEnumerable<OrderLine> Lines)> GetOrderDetailsAsync(int orderId)
{
    using var conn = Open();

    using var multi = await conn.QueryMultipleAsync(@"
        SELECT id, total, status, customer_id, ordered_at
        FROM orders
        WHERE id = @OrderId;

        SELECT ol.id, ol.quantity, ol.unit_price, ol.product_id, p.name AS ProductName
        FROM order_lines ol
        INNER JOIN products p ON p.id = ol.product_id
        WHERE ol.order_id = @OrderId;",
        new { OrderId = orderId });

    var order = await multi.ReadFirstOrDefaultAsync<Order>();
    var lines = await multi.ReadAsync<OrderLine>();

    return (order, lines);
}

// Usage:
var (order, lines) = await repo.GetOrderDetailsAsync(42);
if (order is null) return Results.NotFound();

// More complex: order + lines + customer in one trip
using var multi = await conn.QueryMultipleAsync(@"
    SELECT * FROM orders WHERE id = @Id;
    SELECT * FROM order_lines WHERE order_id = @Id;
    SELECT c.* FROM customers c
    INNER JOIN orders o ON o.customer_id = c.id
    WHERE o.id = @Id;",
    new { Id = orderId });

var order = await multi.ReadSingleOrDefaultAsync<Order>();
var lines = (await multi.ReadAsync<OrderLine>()).ToList();
var customer = await multi.ReadSingleOrDefaultAsync<Customer>();
```

<ConceptCallout type="tip" title="QueryMultiple vs Multiple Round Trips">
`QueryMultiple` sends all queries to the database in a single network call, which is more efficient than calling `QueryAsync` three times separately. Use it when you need related data from multiple tables and want to avoid N+1 round trips without writing a complex JOIN.
</ConceptCallout>

## When to Use Each Approach

```csharp
// Use multi-mapping (JOIN + splitOn) when:
// - You want the database to do the join (optimal query plan)
// - The result set is reasonably sized
// - One-to-one or many-to-one relationships (Order → Customer)

var orderWithCustomer = await conn.QueryAsync<Order, Customer, Order>(
    "SELECT ... FROM orders o JOIN customers c ON ...",
    (o, c) => { o.Customer = c; return o; }, splitOn: "id");

// Use Dictionary pattern when:
// - One-to-many: one Order has many Lines (JOIN duplicates rows)

var orderWithLines = await GetOrderWithLinesAsync(orderId);  // uses dictionary

// Use QueryMultiple when:
// - You need multiple independent result sets
// - The data isn't naturally JOIN-able (or would create a Cartesian product)
// - You want to avoid the complexity of multi-level nested maps

var (order, lines) = await GetOrderDetailsAsync(orderId);  // uses QueryMultiple
```

<ExerciseBlock>
1. Write `GetProductWithCategoryAsync(int productId)` using multi-mapping to populate `Product.Category`. Then write `GetProductsByCategoryAsync(int categoryId)` returning all products in a category, each with the category populated. Verify with SQL logging that each is a single query.
2. Implement `GetCustomerWithOrdersAsync(int customerId)` using the dictionary pattern. The result should be a `Customer` with a populated `Orders` list. Write a second method `GetCustomerOrderSummariesAsync(int customerId)` using `QueryMultiple` to return the customer info and a separate list of order summaries (no dictionary needed since the orders are read independently).
3. Benchmark two approaches for loading an order with 20 lines: (a) single JOIN with dictionary deduplication, (b) `QueryMultiple` with two queries. Measure round trips and total data transferred. When would you prefer each approach?
</ExerciseBlock>
