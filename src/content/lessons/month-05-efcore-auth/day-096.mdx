---
title: "Dapper: Transactions"
day: 96
week: 20
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "sqflite transactions, atomic operations in Dart"
csharpConcept: "IDbTransaction, BeginTransaction, Commit, Rollback, sharing transactions across repositories"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Transactions in Dapper are explicit: you call `connection.BeginTransaction()`, pass the transaction to each Dapper call, and commit or roll back. There's no automatic transaction wrapping like EF Core's `SaveChangesAsync()` — you control every step.

## Basic Transaction

```csharp
public async Task PlaceOrderAsync(PlaceOrderRequest request)
{
    using var conn = Open();
    await conn.OpenAsync();  // must be open before BeginTransaction

    await using var tx = await conn.BeginTransactionAsync();
    try
    {
        // Step 1: Reserve inventory
        foreach (var item in request.Items)
        {
            var affected = await conn.ExecuteAsync(@"
                UPDATE products
                SET stock_quantity = stock_quantity - @Quantity
                WHERE id = @ProductId AND stock_quantity >= @Quantity",
                new { item.ProductId, item.Quantity },
                transaction: tx);  // ← pass the transaction to every Dapper call

            if (affected == 0)
                throw new InvalidOperationException($"Insufficient stock for product {item.ProductId}");
        }

        // Step 2: Insert the order
        var orderId = await conn.QuerySingleAsync<int>(@"
            INSERT INTO orders (customer_id, total, status, ordered_at)
            VALUES (@CustomerId, @Total, 'Pending', @Now);
            SELECT last_insert_rowid();",
            new { request.CustomerId, Total = request.Items.Sum(i => i.Total), Now = DateTime.UtcNow },
            transaction: tx);

        // Step 3: Insert order lines
        foreach (var item in request.Items)
        {
            await conn.ExecuteAsync(@"
                INSERT INTO order_lines (order_id, product_id, quantity, unit_price)
                VALUES (@OrderId, @ProductId, @Quantity, @UnitPrice)",
                new { OrderId = orderId, item.ProductId, item.Quantity, item.UnitPrice },
                transaction: tx);
        }

        await tx.CommitAsync();  // all or nothing
    }
    catch
    {
        await tx.RollbackAsync();
        throw;
    }
}
```

<ConceptCallout type="tip" title="Always Pass the Transaction">
Every Dapper call inside a transaction must receive the `transaction:` parameter. If you forget it on even one call, that query runs outside the transaction — it won't be rolled back if something fails. This is the most common Dapper transaction mistake.
</ConceptCallout>

## Sharing a Transaction Across Repositories

```csharp
// Problem: PlaceOrderAsync needs to update inventory (ProductRepository)
// and create an order (OrderRepository) in the same transaction.
// Solution: pass the connection + transaction to both repositories.

// Pattern: accept connection + transaction as parameters
public class ProductRepository
{
    public async Task<bool> ReserveStockAsync(
        IDbConnection conn,
        IDbTransaction tx,
        int productId,
        int quantity)
    {
        var affected = await conn.ExecuteAsync(@"
            UPDATE products
            SET stock_quantity = stock_quantity - @Quantity
            WHERE id = @ProductId AND stock_quantity >= @Quantity",
            new { ProductId = productId, Quantity = quantity },
            transaction: tx);

        return affected > 0;  // false = insufficient stock
    }
}

public class OrderRepository
{
    public async Task<int> CreateAsync(
        IDbConnection conn,
        IDbTransaction tx,
        Order order)
    {
        return await conn.QuerySingleAsync<int>(@"
            INSERT INTO orders (customer_id, total, status, ordered_at)
            VALUES (@CustomerId, @Total, @Status, @OrderedAt);
            SELECT last_insert_rowid();",
            order,
            transaction: tx);
    }
}

// Service that coordinates the transaction:
public class OrderService(
    ProductRepository productRepo,
    OrderRepository orderRepo,
    IConfiguration config)
{
    public async Task<int> PlaceOrderAsync(PlaceOrderRequest request)
    {
        using var conn = new SqliteConnection(config.GetConnectionString("Default"));
        await conn.OpenAsync();
        await using var tx = await conn.BeginTransactionAsync();

        try
        {
            // Both repositories share the same connection + transaction
            foreach (var item in request.Items)
            {
                var reserved = await productRepo.ReserveStockAsync(conn, tx, item.ProductId, item.Quantity);
                if (!reserved)
                    throw new InsufficientStockException(item.ProductId);
            }

            var orderId = await orderRepo.CreateAsync(conn, tx, new Order
            {
                CustomerId = request.CustomerId,
                Total = request.Items.Sum(i => i.Total),
                Status = "Pending",
                OrderedAt = DateTime.UtcNow
            });

            await tx.CommitAsync();
            return orderId;
        }
        catch
        {
            await tx.RollbackAsync();
            throw;
        }
    }
}
```

## Isolation Levels

```csharp
// Default isolation level is typically ReadCommitted
// For financial operations, use a higher level

await using var tx = await conn.BeginTransactionAsync(
    IsolationLevel.RepeatableRead);  // prevents dirty reads + non-repeatable reads

// Common choices:
// ReadUncommitted — see uncommitted data (dirty reads) — rarely appropriate
// ReadCommitted   — default, sees committed data only
// RepeatableRead  — rows read can't be modified by others until tx ends
// Serializable    — strongest, full isolation (slowest, most blocking)
// Snapshot        — SQL Server: read a consistent snapshot, no blocking on reads
```

## Savepoints — Partial Rollback

```csharp
// SQL Server and PostgreSQL support savepoints within a transaction
// Roll back to a savepoint without rolling back the entire transaction

await using var tx = await conn.BeginTransactionAsync();

await conn.ExecuteAsync("INSERT INTO orders ...", orderParams, transaction: tx);

// Create a savepoint after the order insert
await conn.ExecuteAsync("SAVE TRANSACTION AfterOrder", transaction: tx);
// PostgreSQL: "SAVEPOINT AfterOrder"

try
{
    // Try to process payment (might fail)
    await conn.ExecuteAsync("INSERT INTO payments ...", paymentParams, transaction: tx);
    await tx.CommitAsync();
}
catch (PaymentException)
{
    // Roll back only to the savepoint — keeps the order record
    await conn.ExecuteAsync("ROLLBACK TRANSACTION AfterOrder", transaction: tx);
    // PostgreSQL: "ROLLBACK TO SAVEPOINT AfterOrder"

    // Update order status to reflect payment failure
    await conn.ExecuteAsync(
        "UPDATE orders SET status = 'PaymentFailed' WHERE id = @Id",
        new { Id = orderId },
        transaction: tx);

    await tx.CommitAsync();  // commit the order with failed-payment status
}
```

## Transaction Timeout

```csharp
// Long-running transactions can cause blocking
// Set a command timeout per query to avoid hanging

await conn.ExecuteAsync(
    "UPDATE products SET price = price * 1.1 WHERE category_id = @CatId",
    new { CatId = 5 },
    transaction: tx,
    commandTimeout: 30);  // seconds — throws if query takes longer
```

## Read-Only Queries in a Transaction

```csharp
// You can also read within a transaction to see your own uncommitted changes
public async Task<Order> PlaceOrderAndReturnAsync(PlaceOrderRequest request)
{
    using var conn = Open();
    await conn.OpenAsync();
    await using var tx = await conn.BeginTransactionAsync();

    try
    {
        // Insert the order
        var orderId = await conn.QuerySingleAsync<int>(
            "INSERT INTO orders ... ; SELECT last_insert_rowid();",
            new { /* ... */ },
            transaction: tx);

        // Read back what we just inserted (same transaction — sees our changes)
        var order = await conn.QuerySingleAsync<Order>(
            "SELECT * FROM orders WHERE id = @Id",
            new { Id = orderId },
            transaction: tx);  // same transaction — sees uncommitted insert

        await tx.CommitAsync();
        return order;
    }
    catch
    {
        await tx.RollbackAsync();
        throw;
    }
}
```

<ConceptCallout type="gotcha" title="Connection Must Be Open Before BeginTransaction">
Unlike EF Core's `DbContext`, Dapper requires you to explicitly open the connection before calling `BeginTransaction`. Call `await conn.OpenAsync()` before `conn.BeginTransaction()`. Forgetting this throws `InvalidOperationException: The connection is not open`.
</ConceptCallout>

<ExerciseBlock>
1. Build a `TransferFundsAsync(int fromAccountId, int toAccountId, decimal amount)` method using a Dapper transaction. The transfer should: check the from-account has sufficient balance (fail if not), debit the from-account, credit the to-account, and log the transfer. Verify with a test that if the credit fails, the debit is rolled back.
2. Implement a `BulkUpdateInventoryAsync(IEnumerable<InventoryUpdate> updates)` that processes all updates in a single transaction. If any update would push stock below zero, roll back all updates. Return the number of items updated, or throw with the product ID that caused the failure.
3. Create an `OrderService` that coordinates `ProductRepository` (for stock reservation) and `OrderRepository` (for order creation) in a shared transaction. Pass the `IDbConnection` and `IDbTransaction` to both repositories. Write a test verifying that if the order insert fails, the inventory reservation is also rolled back.
</ExerciseBlock>
