---
title: "Dapper: Stored Procedures and Advanced Queries"
day: 95
week: 19
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "raw SQL custom queries in sqflite, calling database functions"
csharpConcept: "CommandType.StoredProcedure, output parameters, table-valued functions, CTEs, window functions"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

One of Dapper's biggest advantages over EF Core is that you can use the full power of SQL: stored procedures, CTEs, window functions, table-valued functions, and vendor-specific features. Dapper executes what you give it — no translation layer to fight.

## Calling Stored Procedures

```csharp
// Stored procedure with parameters
public async Task<IEnumerable<Order>> GetOrdersByCustomerAsync(int customerId)
{
    using var conn = Open();
    return await conn.QueryAsync<Order>(
        "sp_GetOrdersByCustomer",          // procedure name
        new { CustomerId = customerId },   // input parameters
        commandType: CommandType.StoredProcedure);
}

// Stored procedure returning no rows (just executes an action)
public async Task ArchiveOldOrdersAsync(DateTime olderThan)
{
    using var conn = Open();
    await conn.ExecuteAsync(
        "sp_ArchiveOrders",
        new { OlderThan = olderThan },
        commandType: CommandType.StoredProcedure);
}

// Stored procedure with output parameters
public async Task<(int OrderCount, decimal TotalRevenue)> GetCustomerStatsAsync(int customerId)
{
    using var conn = Open();

    var parameters = new DynamicParameters();
    parameters.Add("@CustomerId", customerId, DbType.Int32);
    parameters.Add("@OrderCount",    dbType: DbType.Int32,    direction: ParameterDirection.Output);
    parameters.Add("@TotalRevenue",  dbType: DbType.Decimal,  direction: ParameterDirection.Output);

    await conn.ExecuteAsync(
        "sp_GetCustomerStats",
        parameters,
        commandType: CommandType.StoredProcedure);

    return (
        parameters.Get<int>("@OrderCount"),
        parameters.Get<decimal>("@TotalRevenue")
    );
}
```

## Stored Procedure with Multiple Result Sets

```csharp
// One stored procedure, multiple SELECT statements
public async Task<OrderDetailResponse> GetOrderDetailAsync(int orderId)
{
    using var conn = Open();

    using var multi = await conn.QueryMultipleAsync(
        "sp_GetOrderDetail",
        new { OrderId = orderId },
        commandType: CommandType.StoredProcedure);

    var order    = await multi.ReadSingleOrDefaultAsync<Order>();
    var lines    = await multi.ReadAsync<OrderLine>();
    var customer = await multi.ReadSingleOrDefaultAsync<Customer>();

    if (order is null) return OrderDetailResponse.NotFound;

    return new OrderDetailResponse(order, lines.ToList(), customer);
}
```

## Common Table Expressions (CTEs)

```csharp
// CTEs make complex queries readable — Dapper just sends the SQL
public async Task<IEnumerable<CustomerRanking>> GetTopCustomersAsync(int topN)
{
    using var conn = Open();
    return await conn.QueryAsync<CustomerRanking>(@"
        WITH CustomerStats AS (
            SELECT
                c.id           AS CustomerId,
                c.name         AS CustomerName,
                COUNT(o.id)    AS OrderCount,
                SUM(o.total)   AS TotalSpent
            FROM customers c
            LEFT JOIN orders o ON o.customer_id = c.id
              AND o.status != 'Cancelled'
            GROUP BY c.id, c.name
        ),
        Ranked AS (
            SELECT
                *,
                RANK() OVER (ORDER BY TotalSpent DESC) AS SpendingRank
            FROM CustomerStats
        )
        SELECT *
        FROM Ranked
        WHERE SpendingRank <= @TopN
        ORDER BY SpendingRank",
        new { TopN = topN });
}

public class CustomerRanking
{
    public int CustomerId { get; set; }
    public string CustomerName { get; set; } = "";
    public int OrderCount { get; set; }
    public decimal TotalSpent { get; set; }
    public int SpendingRank { get; set; }
}
```

## Window Functions

```csharp
// Running totals, rankings, moving averages — all work in Dapper
public async Task<IEnumerable<MonthlySalesRow>> GetMonthlySalesWithRunningTotalAsync()
{
    using var conn = Open();
    return await conn.QueryAsync<MonthlySalesRow>(@"
        SELECT
            strftime('%Y-%m', ordered_at) AS Month,
            COUNT(*)                       AS OrderCount,
            SUM(total)                     AS MonthlyRevenue,
            SUM(SUM(total)) OVER (
                ORDER BY strftime('%Y-%m', ordered_at)
            )                              AS RunningTotal,
            AVG(SUM(total)) OVER (
                ORDER BY strftime('%Y-%m', ordered_at)
                ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
            )                              AS MovingAvg3Month
        FROM orders
        WHERE status = 'Completed'
        GROUP BY strftime('%Y-%m', ordered_at)
        ORDER BY Month");
}

public class MonthlySalesRow
{
    public string Month { get; set; } = "";
    public int OrderCount { get; set; }
    public decimal MonthlyRevenue { get; set; }
    public decimal RunningTotal { get; set; }
    public decimal MovingAvg3Month { get; set; }
}
```

## Upsert — Insert or Update

```csharp
// SQL Server: MERGE statement
public async Task UpsertProductAsync(Product product)
{
    using var conn = Open();
    await conn.ExecuteAsync(@"
        MERGE INTO products AS target
        USING (SELECT @Sku AS Sku) AS source ON target.sku = source.Sku
        WHEN MATCHED THEN
            UPDATE SET
                name       = @Name,
                price      = @Price,
                updated_at = @UpdatedAt
        WHEN NOT MATCHED THEN
            INSERT (sku, name, price, created_at, updated_at)
            VALUES (@Sku, @Name, @Price, @CreatedAt, @UpdatedAt);",
        new
        {
            product.Sku,
            product.Name,
            product.Price,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        });
}

// SQLite / PostgreSQL: INSERT OR REPLACE / ON CONFLICT
await conn.ExecuteAsync(@"
    INSERT INTO products (sku, name, price, created_at, updated_at)
    VALUES (@Sku, @Name, @Price, @CreatedAt, @UpdatedAt)
    ON CONFLICT (sku) DO UPDATE SET
        name       = excluded.name,
        price      = excluded.price,
        updated_at = excluded.updated_at",
    new { product.Sku, product.Name, product.Price,
          CreatedAt = DateTime.UtcNow, UpdatedAt = DateTime.UtcNow });
```

## Recursive CTEs — Hierarchical Data

```csharp
// Get all replies in a comment thread (arbitrarily deep)
public async Task<IEnumerable<Comment>> GetCommentThreadAsync(int rootCommentId)
{
    using var conn = Open();
    return await conn.QueryAsync<Comment>(@"
        WITH RECURSIVE CommentTree AS (
            -- Base case: the root comment
            SELECT id, body, parent_id, author_name, created_at, 0 AS depth
            FROM comments
            WHERE id = @RootId

            UNION ALL

            -- Recursive case: all replies
            SELECT c.id, c.body, c.parent_id, c.author_name, c.created_at, ct.depth + 1
            FROM comments c
            INNER JOIN CommentTree ct ON c.parent_id = ct.id
        )
        SELECT * FROM CommentTree ORDER BY depth, created_at",
        new { RootId = rootCommentId });
}
```

## Pagination with Keyset (Cursor) Pagination

```csharp
// Offset pagination: slow at high page numbers (DB must skip N rows)
// Keyset pagination: fast regardless of depth (uses an index)

public async Task<PagedResult<Order>> GetOrdersPageAsync(
    DateTime? afterDate = null,
    int? afterId = null,
    int pageSize = 20)
{
    using var conn = Open();

    var orders = await conn.QueryAsync<Order>(@"
        SELECT id, total, status, ordered_at, customer_id
        FROM orders
        WHERE (@AfterDate IS NULL
               OR (ordered_at < @AfterDate)
               OR (ordered_at = @AfterDate AND id < @AfterId))
          AND status != 'Cancelled'
        ORDER BY ordered_at DESC, id DESC
        LIMIT @PageSize",
        new { AfterDate = afterDate, AfterId = afterId ?? int.MaxValue, PageSize = pageSize + 1 });

    var list = orders.ToList();
    var hasMore = list.Count > pageSize;
    if (hasMore) list.RemoveAt(list.Count - 1);

    var nextCursor = hasMore
        ? (list.Last().OrderedAt, list.Last().Id)
        : ((DateTime?)null, (int?)null);

    return new PagedResult<Order>(list, hasMore, nextCursor);
}
```

<ConceptCallout type="tip" title="Use the Full Power of SQL">
With Dapper, complex SQL is a feature, not a workaround. CTEs, window functions, recursive queries, MERGE statements — write them directly. With EF Core, you'd need raw SQL fallbacks for these anyway. Dapper makes SQL first-class from day one.
</ConceptCallout>

<ExerciseBlock>
1. Create a stored procedure `sp_GetOrderSummary` (or use a CTE if your database doesn't support stored procs well) that accepts `@CustomerId` and returns: customer info, total order count, total spent, most recent order date, and most purchased product name. Call it from a Dapper repository method.
2. Write a `GetSalesByMonthAsync(int year)` method using a GROUP BY with window functions to return monthly revenue, order count, and a running total for the year. Map the result to a `MonthlySalesDto` and return from a Minimal API endpoint.
3. Implement keyset pagination for a `GetOrdersAsync` endpoint that accepts an optional cursor (last seen `ordered_at` + `id`). Verify with a large dataset (seed 10,000 orders) that fetching page 500 takes the same time as fetching page 1.
</ExerciseBlock>
