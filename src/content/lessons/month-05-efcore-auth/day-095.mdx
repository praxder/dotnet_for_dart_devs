---
title: "EF Core: Raw SQL and Database Views"
day: 95
week: 19
module: 8
moduleName: "Entity Framework Core"
phase: "dotnet"
dartConcept: "drift custom queries, raw SQL in sqflite"
csharpConcept: "FromSql, ExecuteSql, DbFunction, database views, stored procedures, Dapper"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

EF Core generates SQL for most queries, but sometimes you need raw SQL — for complex aggregations, vendor-specific features, stored procedures, or when LINQ generates inefficient queries. EF Core provides safe, parameterized raw SQL alongside full Dapper integration.

## FromSql — Entity Queries with Raw SQL

```csharp
// Returns tracked entities — same as LINQ queries
// IMPORTANT: Use $"" interpolation — EF Core treats it as safe parameterized SQL
var minPrice = 10m;
var products = await db.Products
    .FromSql($"SELECT * FROM products WHERE price >= {minPrice}")
    .ToListAsync();
// Generates: SELECT * FROM products WHERE price >= @p0
// Parameter value is NEVER interpolated into SQL — protected from injection

// Combine with LINQ after FromSql
var filtered = await db.Products
    .FromSql($"SELECT * FROM products WHERE is_active = 1")
    .Where(p => p.CategoryId == 5)       // added as WHERE clause
    .OrderBy(p => p.Price)               // added as ORDER BY
    .Take(20)
    .ToListAsync();
// SQL: SELECT * FROM (SELECT * FROM products WHERE is_active = 1)
//      WHERE CategoryId = 5 ORDER BY Price LIMIT 20
```

<ConceptCallout type="gotcha" title="FromSqlRaw vs FromSql">
EF Core 8+ prefers `FromSql()` with interpolated strings (automatically parameterized). Older code uses `FromSqlRaw()` with `SqlParameter` objects. Never use `FromSqlRaw($"... {userInput}")` — that concatenates directly and causes SQL injection. When using `FromSqlRaw`, always pass parameters explicitly: `FromSqlRaw("SELECT * FROM products WHERE name = {0}", name)`.
</ConceptCallout>

## ExecuteSql — Non-Query Commands

```csharp
// For UPDATE, DELETE, INSERT that don't return entities

// Bulk update without loading entities
var cutoffDate = DateTime.UtcNow.AddDays(-90);
int rowsAffected = await db.Database.ExecuteSqlAsync(
    $"UPDATE orders SET status = 'Archived' WHERE created_at < {cutoffDate}");

// Bulk delete (EF Core 7+ also has ExecuteDeleteAsync via LINQ)
await db.Database.ExecuteSqlAsync(
    $"DELETE FROM audit_logs WHERE created_at < {DateTime.UtcNow.AddYears(-1)}");

// EF Core 7+ — LINQ-based bulk operations (no SQL needed):
await db.AuditLogs
    .Where(a => a.CreatedAt < DateTime.UtcNow.AddYears(-1))
    .ExecuteDeleteAsync();  // single DELETE SQL, no entity loading

await db.Products
    .Where(p => p.CategoryId == 5)
    .ExecuteUpdateAsync(setters => setters
        .SetProperty(p => p.IsActive, false)
        .SetProperty(p => p.UpdatedAt, DateTime.UtcNow));
// Single UPDATE SQL: UPDATE products SET is_active=0, updated_at=@p WHERE category_id=5
```

## Stored Procedures

```csharp
// Call a stored procedure that returns entities
var customerId = 42;
var orders = await db.Orders
    .FromSql($"EXEC sp_GetOrdersByCustomer {customerId}")
    .ToListAsync();

// For stored procedures that don't return entity shape — use keyless entity
[Keyless]  // no primary key
public class SalesReport
{
    public string Month { get; set; } = "";
    public decimal Revenue { get; set; }
    public int OrderCount { get; set; }
}

// Register in DbContext:
public DbSet<SalesReport> SalesReports { get; set; }

modelBuilder.Entity<SalesReport>().HasNoKey().ToView(null);  // no table/view mapped

// Query:
var report = await db.SalesReports
    .FromSql($"EXEC sp_GetSalesReport {year}")
    .ToListAsync();

// Output parameters — use raw ADO.NET:
var outputParam = new SqlParameter("@TotalCount", SqlDbType.Int)
{
    Direction = ParameterDirection.Output
};
await db.Database.ExecuteSqlRawAsync(
    "EXEC sp_ProcessBatch @InputId, @TotalCount OUTPUT",
    new SqlParameter("@InputId", batchId), outputParam);
int totalCount = (int)outputParam.Value;
```

## Database Views

```csharp
// Map EF Core entity to a view (read-only)
public class OrderSummaryView
{
    public int OrderId { get; set; }
    public string CustomerName { get; set; } = "";
    public int ItemCount { get; set; }
    public decimal Total { get; set; }
    public DateTime OrderedAt { get; set; }
}

// Configure in OnModelCreating:
modelBuilder.Entity<OrderSummaryView>(entity =>
{
    entity.HasNoKey();
    entity.ToView("vw_order_summaries");  // maps to existing view
});

// Register in DbContext:
public DbSet<OrderSummaryView> OrderSummaries { get; set; }

// Query just like a table:
var recent = await db.OrderSummaries
    .Where(o => o.OrderedAt > DateTime.UtcNow.AddDays(-7))
    .OrderByDescending(o => o.Total)
    .Take(10)
    .ToListAsync();
```

## DbFunctions — SQL Functions in LINQ

```csharp
// Map SQL functions so you can use them in LINQ queries
public class AppDbContext : DbContext
{
    // Map to SQL SOUNDEX function
    [DbFunction("SOUNDEX", IsBuiltIn = true)]
    public static string Soundex(string value) => throw new NotSupportedException();

    // Map to a custom SQL function
    [DbFunction("fn_LevenshteinDistance")]
    public static int LevenshteinDistance(string s1, string s2)
        => throw new NotSupportedException();  // only called in SQL translation
}

// Use in LINQ:
var similar = await db.Customers
    .Where(c => AppDbContext.Soundex(c.LastName) == AppDbContext.Soundex("Smith"))
    .ToListAsync();
// SQL: WHERE SOUNDEX(last_name) = SOUNDEX('Smith')

// EF.Functions — built-in SQL function mappings:
var recent = await db.Orders
    .Where(o => EF.Functions.DateDiffDay(o.OrderedAt, DateTime.UtcNow) <= 30)
    .ToListAsync();

var textSearch = await db.Articles
    .Where(a => EF.Functions.FreeText(a.Body, "machine learning"))
    .ToListAsync();
```

## Dapper — Micro ORM Alongside EF Core

```csharp
// Install: dotnet add package Dapper
// Use when: complex queries, maximum performance, or non-entity shapes

// Access the underlying connection:
var connection = db.Database.GetDbConnection();

// Simple Dapper query
var stats = await connection.QueryAsync<CustomerStats>(@"
    SELECT
        c.Id,
        c.Name,
        COUNT(o.Id) AS OrderCount,
        SUM(o.Total) AS TotalSpent,
        MAX(o.OrderedAt) AS LastOrder
    FROM customers c
    LEFT JOIN orders o ON o.customer_id = c.id
    WHERE c.is_active = 1
    GROUP BY c.Id, c.Name
    ORDER BY TotalSpent DESC
    LIMIT @Take",
    new { Take = 100 });

// Within an EF Core transaction:
await using var tx = await db.Database.BeginTransactionAsync();
await connection.ExecuteAsync(
    "UPDATE inventory SET reserved = reserved + @Qty WHERE product_id = @Id",
    new { Qty = quantity, Id = productId },
    transaction: tx.GetDbTransaction());  // share the transaction
await db.SaveChangesAsync();
await tx.CommitAsync();
```

<ConceptCallout type="tip" title="EF Core + Dapper = Best of Both">
Use EF Core for your standard CRUD and relationship management. Drop down to Dapper for reporting queries, complex aggregations, or bulk operations where you don't need entity tracking. They work perfectly together on the same connection and transaction.
</ConceptCallout>

<ExerciseBlock>
1. Create a `ProductSearchService` that uses `FromSql` to call a full-text search stored procedure (or view), then applies LINQ `.Where()`, `.OrderBy()`, and `.Take()` on top of the raw SQL result.
2. Use `ExecuteUpdateAsync` and `ExecuteDeleteAsync` (EF Core 7+) to implement "archive orders older than 90 days" — mark them as archived in a bulk update, then delete archived logs older than 1 year. Compare query count and performance against the loop-based approach.
3. Map a `vw_monthly_revenue` view to a keyless entity and query it from a Minimal API endpoint. Include a Dapper query on the same connection that runs a more complex aggregation. Return both results in one response DTO.
</ExerciseBlock>
