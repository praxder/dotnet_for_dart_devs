---
title: "Dapper: Type Handlers and Custom Mapping"
day: 103
week: 21
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "custom type converters in Dart, JSON serialization"
csharpConcept: "SqlMapper.TypeHandler, enum mapping, JSON columns, value objects, column naming"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Dapper's default mapping handles the common cases, but real-world databases often store data in ways that need custom conversion: enums as strings, value objects, JSON columns, or dates in specific formats. `SqlMapper.TypeHandler<T>` is Dapper's extension point for all of these.

## Default Mapping Behavior

```csharp
// Dapper maps by name (case-insensitive) between column names and property names
// Works out of the box:
//   Column "id"         → Property "Id"
//   Column "name"       → Property "Name"

// Enable underscore-to-PascalCase mapping globally:
DefaultTypeMap.MatchNamesWithUnderscores = true;
// Now:
//   Column "category_id" → Property "CategoryId"
//   Column "is_active"   → Property "IsActive"
//   Column "created_at"  → Property "CreatedAt"

// Add this in Program.cs before any Dapper calls
```

## Enum Mapping — String ↔ C# Enum

```csharp
// Problem: your DB stores "Pending", "Completed", "Cancelled" as TEXT
// You want to map to an OrderStatus enum

public enum OrderStatus { Pending, Processing, Completed, Cancelled }

// Solution: TypeHandler<T>
public class EnumTypeHandler<T> : SqlMapper.TypeHandler<T> where T : struct, Enum
{
    public override void SetValue(IDbDataParameter parameter, T value)
    {
        parameter.DbType = DbType.String;
        parameter.Value = value.ToString();  // "Pending", "Completed", etc.
    }

    public override T Parse(object value)
    {
        return Enum.Parse<T>(value.ToString()!, ignoreCase: true);
    }
}

// Registration (once, at startup, in Program.cs):
SqlMapper.AddTypeHandler(new EnumTypeHandler<OrderStatus>());
SqlMapper.AddTypeHandler(new EnumTypeHandler<ProductStatus>());
// Add one per enum type you use

// Now Dapper reads "Pending" from DB → OrderStatus.Pending in C#
// And writes OrderStatus.Pending → "Pending" to DB
```

## JSON Column Mapping

```csharp
// Modern databases support JSON columns (SQL Server 2016+, PostgreSQL, SQLite)
// Store complex objects as JSON in a single column

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = "";
    public decimal Price { get; set; }
    public ProductAttributes Attributes { get; set; } = new();  // stored as JSON
}

public class ProductAttributes
{
    public List<string> Colors { get; set; } = [];
    public Dictionary<string, string> Specs { get; set; } = [];
    public string? Brand { get; set; }
}

// TypeHandler for JSON deserialization:
public class JsonTypeHandler<T> : SqlMapper.TypeHandler<T>
{
    private static readonly JsonSerializerOptions Options = new()
    {
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    public override void SetValue(IDbDataParameter parameter, T? value)
    {
        parameter.DbType = DbType.String;
        parameter.Value = value is null ? DBNull.Value : JsonSerializer.Serialize(value, Options);
    }

    public override T Parse(object value)
    {
        var json = value.ToString()!;
        return JsonSerializer.Deserialize<T>(json, Options)
            ?? throw new InvalidOperationException($"Failed to deserialize JSON to {typeof(T).Name}");
    }
}

// Registration:
SqlMapper.AddTypeHandler(new JsonTypeHandler<ProductAttributes>());
SqlMapper.AddTypeHandler(new JsonTypeHandler<Dictionary<string, string>>());

// Usage — Dapper auto-serializes/deserializes:
var product = await conn.QueryFirstOrDefaultAsync<Product>(
    "SELECT id, name, price, attributes FROM products WHERE id = @Id",
    new { Id = 42 });

Console.WriteLine(product?.Attributes.Brand);  // "Acme"
// The "attributes" column contains: {"brand":"Acme","colors":["red","blue"]}
```

## Value Object Mapping

```csharp
// Map a Money value object: stored as two columns (amount + currency)
// Note: TypeHandler works for single-column mapping.
// For multi-column value objects, use manual mapping.

// Single column: store money as "9.99 USD"
public record Money(decimal Amount, string Currency);

public class MoneyTypeHandler : SqlMapper.TypeHandler<Money>
{
    public override void SetValue(IDbDataParameter parameter, Money value)
    {
        parameter.DbType = DbType.String;
        parameter.Value = $"{value.Amount} {value.Currency}";
    }

    public override Money Parse(object value)
    {
        var parts = value.ToString()!.Split(' ');
        return new Money(decimal.Parse(parts[0]), parts[1]);
    }
}

SqlMapper.AddTypeHandler(new MoneyTypeHandler());

// For multi-column value objects, read them separately and construct:
public record Address(string Street, string City, string Country);

// In your query, alias columns to match your construction:
var customer = await conn.QueryFirstOrDefaultAsync<dynamic>(@"
    SELECT id, name,
           street, city, country
    FROM customers WHERE id = @Id",
    new { Id = 42 });

if (customer is not null)
{
    return new Customer
    {
        Id = customer.id,
        Name = customer.name,
        ShippingAddress = new Address(customer.street, customer.city, customer.country)
    };
}
```

## DateTimeOffset and UTC Dates

```csharp
// SQLite stores dates as TEXT ("2024-01-15T12:00:00Z")
// Dapper parses to DateTime but may strip timezone info

public class DateTimeOffsetHandler : SqlMapper.TypeHandler<DateTimeOffset>
{
    public override void SetValue(IDbDataParameter parameter, DateTimeOffset value)
    {
        parameter.DbType = DbType.String;
        parameter.Value = value.ToString("O");  // ISO 8601 with offset
    }

    public override DateTimeOffset Parse(object value)
    {
        return DateTimeOffset.Parse(value.ToString()!, null,
            System.Globalization.DateTimeStyles.RoundtripKind);
    }
}

public class NullableDateTimeOffsetHandler : SqlMapper.TypeHandler<DateTimeOffset?>
{
    public override void SetValue(IDbDataParameter parameter, DateTimeOffset? value)
    {
        parameter.DbType = DbType.String;
        parameter.Value = value?.ToString("O") ?? (object)DBNull.Value;
    }

    public override DateTimeOffset? Parse(object value)
    {
        if (value is DBNull || value is null || string.IsNullOrEmpty(value.ToString()))
            return null;
        return DateTimeOffset.Parse(value.ToString()!, null,
            System.Globalization.DateTimeStyles.RoundtripKind);
    }
}

// Register both:
SqlMapper.AddTypeHandler(new DateTimeOffsetHandler());
SqlMapper.AddTypeHandler(new NullableDateTimeOffsetHandler());
```

## Custom Column Name Mapping

```csharp
// When column names and property names don't match,
// use SQL aliases instead of TypeHandlers

// Option 1: SQL aliases (most explicit, no magic)
var products = await conn.QueryAsync<Product>(@"
    SELECT
        product_id   AS Id,
        product_name AS Name,
        unit_price   AS Price,
        cat_id       AS CategoryId
    FROM tbl_products");

// Option 2: Custom type mapper (for legacy databases with odd naming)
public class LegacyProductTypeMap : SqlMapper.ITypeMap
{
    private static readonly Dictionary<string, string> ColumnToProperty =
        new(StringComparer.OrdinalIgnoreCase)
        {
            ["product_id"]   = "Id",
            ["product_name"] = "Name",
            ["unit_price"]   = "Price",
            ["cat_id"]       = "CategoryId"
        };

    // ... implement ITypeMap interface ...
}

SqlMapper.SetTypeMap(typeof(Product), new LegacyProductTypeMap());
```

## Type Handler Registration — Best Practice

```csharp
// Register all handlers once at startup in a static class
// Call this from Program.cs before any Dapper queries run

public static class DapperConfiguration
{
    public static void Configure()
    {
        // Enable snake_case → PascalCase mapping
        DefaultTypeMap.MatchNamesWithUnderscores = true;

        // Enum handlers
        SqlMapper.AddTypeHandler(new EnumTypeHandler<OrderStatus>());
        SqlMapper.AddTypeHandler(new EnumTypeHandler<ProductStatus>());
        SqlMapper.AddTypeHandler(new EnumTypeHandler<UserRole>());

        // JSON handlers
        SqlMapper.AddTypeHandler(new JsonTypeHandler<ProductAttributes>());
        SqlMapper.AddTypeHandler(new JsonTypeHandler<OrderMetadata>());
        SqlMapper.AddTypeHandler(new JsonTypeHandler<List<string>>());

        // Date handlers
        SqlMapper.AddTypeHandler(new DateTimeOffsetHandler());
        SqlMapper.AddTypeHandler(new NullableDateTimeOffsetHandler());

        // Value object handlers
        SqlMapper.AddTypeHandler(new MoneyTypeHandler());
    }
}

// In Program.cs:
DapperConfiguration.Configure();
```

<ExerciseBlock>
1. Create an `OrderStatus` enum with values `Pending`, `Processing`, `Shipped`, `Delivered`, `Cancelled`. Implement `EnumTypeHandler<OrderStatus>` and register it. Verify that inserting an `Order` with `OrderStatus.Pending` saves "Pending" in the DB, and querying it back gives `OrderStatus.Pending` in C#.
2. Add a `settings` JSON column to the `users` table storing a `UserPreferences` object (notification settings, theme, language). Implement `JsonTypeHandler<UserPreferences>` and verify round-trip serialization via a repository test.
3. Implement a `DateTimeOffsetHandler` for SQLite and register it. Update all timestamp columns in your schema to store ISO 8601 strings. Write a test that inserts a `DateTimeOffset` in UTC+5:30, reads it back, and verifies the offset is preserved correctly.
</ExerciseBlock>
