---
title: "Mini-Project: Blog API Data Layer with Dapper"
day: 100
week: 20
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "Flutter blog app backend, sqflite data layer"
csharpConcept: "Dapper + Minimal APIs + CQRS + Repository, complete data layer"
estimatedMinutes: 45
isProject: true
projectType: "mini"
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

This capstone brings together everything from days 91–99: connection management, CRUD, multi-mapping, transactions, repositories, CQRS with MediatR, and dynamic queries. You'll build the data layer for a blog API using Dapper throughout.

## Project: Blog API — Data Layer

A blog backend with authors, posts, tags, comments, and analytics.

### Database Schema

```sql
-- Run these to create the schema
CREATE TABLE authors (
    id         INTEGER PRIMARY KEY AUTOINCREMENT,
    name       TEXT NOT NULL,
    email      TEXT NOT NULL UNIQUE,
    bio        TEXT NOT NULL DEFAULT '',
    avatar_url TEXT,
    joined_at  TEXT NOT NULL DEFAULT (datetime('now')),
    is_active  INTEGER NOT NULL DEFAULT 1
);

CREATE TABLE posts (
    id           INTEGER PRIMARY KEY AUTOINCREMENT,
    title        TEXT NOT NULL,
    slug         TEXT NOT NULL UNIQUE,
    summary      TEXT NOT NULL DEFAULT '',
    body         TEXT NOT NULL,
    status       TEXT NOT NULL DEFAULT 'Draft',  -- Draft, Published, Archived
    view_count   INTEGER NOT NULL DEFAULT 0,
    author_id    INTEGER NOT NULL REFERENCES authors(id),
    published_at TEXT,
    created_at   TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at   TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE tags (
    id   INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    slug TEXT NOT NULL UNIQUE
);

CREATE TABLE post_tags (
    post_id INTEGER NOT NULL REFERENCES posts(id),
    tag_id  INTEGER NOT NULL REFERENCES tags(id),
    PRIMARY KEY (post_id, tag_id)
);

CREATE TABLE comments (
    id               INTEGER PRIMARY KEY AUTOINCREMENT,
    post_id          INTEGER NOT NULL REFERENCES posts(id),
    parent_id        INTEGER REFERENCES comments(id),
    author_name      TEXT NOT NULL,
    author_email     TEXT NOT NULL,
    body             TEXT NOT NULL,
    is_approved      INTEGER NOT NULL DEFAULT 0,
    created_at       TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Indexes for common queries
CREATE INDEX idx_posts_slug       ON posts(slug);
CREATE INDEX idx_posts_status     ON posts(status, published_at);
CREATE INDEX idx_posts_author     ON posts(author_id);
CREATE INDEX idx_comments_post    ON comments(post_id, is_approved);
```

### DTOs

```csharp
public record PostSummaryDto(
    int Id,
    string Title,
    string Slug,
    string Summary,
    string AuthorName,
    DateTime PublishedAt,
    int ViewCount,
    List<string> Tags,
    int CommentCount);

public record PostDetailDto(
    int Id,
    string Title,
    string Slug,
    string Summary,
    string Body,
    string AuthorName,
    string? AuthorAvatarUrl,
    DateTime PublishedAt,
    int ViewCount,
    List<string> Tags,
    List<CommentDto> Comments);

public record CommentDto(
    int Id,
    string AuthorName,
    string Body,
    DateTime CreatedAt,
    List<CommentDto> Replies);

public record PagedResult<T>(
    List<T> Items,
    int Total,
    int Page,
    int PageSize);
```

### Query Handlers

```csharp
// List posts — with optional tag/author/search filters
public record ListPostsQuery(
    string? Tag = null,
    int? AuthorId = null,
    string? Search = null,
    int Page = 1,
    int PageSize = 20) : IRequest<PagedResult<PostSummaryDto>>;

public class ListPostsHandler(IDbConnectionFactory factory)
    : IRequestHandler<ListPostsQuery, PagedResult<PostSummaryDto>>
{
    public async Task<PagedResult<PostSummaryDto>> Handle(
        ListPostsQuery request, CancellationToken ct)
    {
        using var conn = factory.CreateConnection();

        var builder = new SqlBuilder();

        var dataTemplate = builder.AddTemplate(@"
            SELECT
                p.id, p.title, p.slug, p.summary,
                a.name AS AuthorName,
                p.published_at AS PublishedAt,
                p.view_count AS ViewCount,
                COUNT(DISTINCT c.id) AS CommentCount
            FROM posts p
            INNER JOIN authors a ON a.id = p.author_id
            LEFT JOIN comments c ON c.post_id = p.id AND c.is_approved = 1
            /**where**/
            GROUP BY p.id, p.title, p.slug, p.summary, a.name, p.published_at, p.view_count
            /**orderby**/
            LIMIT @Limit OFFSET @Offset",
            new { Limit = request.PageSize, Offset = (request.Page - 1) * request.PageSize });

        var countTemplate = builder.AddTemplate(@"
            SELECT COUNT(DISTINCT p.id)
            FROM posts p
            /**where**/");

        builder.Where("p.status = 'Published'");

        if (request.Tag is not null)
        {
            builder.Join("post_tags pt ON pt.post_id = p.id");
            builder.Join("tags t ON t.id = pt.tag_id");
            builder.Where("t.slug = @Tag", new { request.Tag });
        }

        if (request.AuthorId.HasValue)
            builder.Where("p.author_id = @AuthorId", new { request.AuthorId });

        if (request.Search is { Length: > 0 } s)
            builder.Where("(p.title LIKE @Search OR p.summary LIKE @Search)",
                new { Search = $"%{s}%" });

        builder.OrderBy("p.published_at DESC");

        using var multi = await conn.QueryMultipleAsync(
            dataTemplate.RawSql + "; " + countTemplate.RawSql,
            dataTemplate.Parameters);

        var posts = (await multi.ReadAsync<dynamic>()).ToList();
        var total = await multi.ReadSingleAsync<int>();

        // Load tags for each post (separate query to avoid Cartesian product)
        if (posts.Count > 0)
        {
            var postIds = posts.Select(p => (int)p.id).ToList();
            var tagsLookup = (await conn.QueryAsync(@"
                SELECT pt.post_id, t.name
                FROM post_tags pt
                INNER JOIN tags t ON t.id = pt.tag_id
                WHERE pt.post_id IN @PostIds",
                new { PostIds = postIds }))
                .GroupBy(r => (int)r.post_id)
                .ToDictionary(g => g.Key, g => g.Select(r => (string)r.name).ToList());

            return new PagedResult<PostSummaryDto>(
                posts.Select(p => new PostSummaryDto(
                    (int)p.id,
                    (string)p.title,
                    (string)p.slug,
                    (string)p.summary,
                    (string)p.AuthorName,
                    DateTime.Parse((string)p.PublishedAt),
                    (int)p.ViewCount,
                    tagsLookup.GetValueOrDefault((int)p.id, []),
                    (int)p.CommentCount)).ToList(),
                total, request.Page, request.PageSize);
        }

        return new PagedResult<PostSummaryDto>([], total, request.Page, request.PageSize);
    }
}

// Get single post by slug
public record GetPostQuery(string Slug) : IRequest<PostDetailDto?>;

public class GetPostHandler(IDbConnectionFactory factory)
    : IRequestHandler<GetPostQuery, PostDetailDto?>
{
    public async Task<PostDetailDto?> Handle(GetPostQuery request, CancellationToken ct)
    {
        using var conn = factory.CreateConnection();

        using var multi = await conn.QueryMultipleAsync(@"
            SELECT p.id, p.title, p.slug, p.summary, p.body,
                   a.name AS AuthorName, a.avatar_url AS AuthorAvatarUrl,
                   p.published_at AS PublishedAt, p.view_count AS ViewCount
            FROM posts p
            INNER JOIN authors a ON a.id = p.author_id
            WHERE p.slug = @Slug AND p.status = 'Published';

            SELECT t.name
            FROM tags t
            INNER JOIN post_tags pt ON pt.tag_id = t.id
            INNER JOIN posts p ON p.id = pt.post_id
            WHERE p.slug = @Slug;

            SELECT id, author_name, body, created_at, parent_id
            FROM comments
            WHERE post_id = (SELECT id FROM posts WHERE slug = @Slug)
              AND is_approved = 1
            ORDER BY created_at ASC;",
            new { request.Slug });

        var post = await multi.ReadFirstOrDefaultAsync<dynamic>();
        if (post is null) return null;

        var tags = (await multi.ReadAsync<string>()).ToList();
        var allComments = (await multi.ReadAsync<dynamic>()).ToList();

        // Increment view count asynchronously (fire and forget for this demo)
        _ = conn.ExecuteAsync(
            "UPDATE posts SET view_count = view_count + 1 WHERE slug = @Slug",
            new { request.Slug });

        // Build comment tree
        var commentDict = allComments
            .Select(c => new CommentDto((int)c.id, (string)c.author_name,
                (string)c.body, DateTime.Parse((string)c.created_at), []))
            .ToDictionary(c => c.Id);

        var rootComments = new List<CommentDto>();
        foreach (var raw in allComments)
        {
            int id = (int)raw.id;
            int? parentId = raw.parent_id is DBNull ? null : (int?)raw.parent_id;
            if (parentId.HasValue && commentDict.TryGetValue(parentId.Value, out var parent))
                parent.Replies.Add(commentDict[id]);
            else
                rootComments.Add(commentDict[id]);
        }

        return new PostDetailDto(
            (int)post.id, (string)post.title, (string)post.slug, (string)post.summary,
            (string)post.body, (string)post.AuthorName, (string?)post.AuthorAvatarUrl,
            DateTime.Parse((string)post.PublishedAt), (int)post.ViewCount,
            tags, rootComments);
    }
}
```

### Command Handlers

```csharp
public record PublishPostCommand(int PostId, int AuthorId) : IRequest<bool>;

public class PublishPostHandler(IDbConnectionFactory factory)
    : IRequestHandler<PublishPostCommand, bool>
{
    public async Task<bool> Handle(PublishPostCommand request, CancellationToken ct)
    {
        using var conn = factory.CreateConnection();

        var affected = await conn.ExecuteAsync(@"
            UPDATE posts
            SET status = 'Published', published_at = @Now, updated_at = @Now
            WHERE id = @PostId
              AND author_id = @AuthorId
              AND status = 'Draft'",
            new { request.PostId, request.AuthorId, Now = DateTime.UtcNow });

        return affected > 0;
    }
}
```

### Minimal API Endpoints

```csharp
var blog = app.MapGroup("/api/blog");

blog.MapGet("/posts", async (
    [AsParameters] ListPostsQuery query,
    IMediator mediator) =>
    Results.Ok(await mediator.Send(query)));

blog.MapGet("/posts/{slug}", async (string slug, IMediator mediator) =>
{
    var post = await mediator.Send(new GetPostQuery(slug));
    return post is null ? Results.NotFound() : Results.Ok(post);
});

blog.MapPost("/posts/{id}/publish", async (
    int id,
    IMediator mediator,
    ClaimsPrincipal user) =>
{
    var authorId = int.Parse(user.FindFirstValue(ClaimTypes.NameIdentifier)!);
    var success = await mediator.Send(new PublishPostCommand(id, authorId));
    return success ? Results.Ok() : Results.Forbid();
}).RequireAuthorization();
```

<ExerciseBlock>
1. Implement `CreatePostCommand` and `UpdatePostCommand` handlers. `CreatePost` should auto-generate the slug from the title (lowercase, spaces → hyphens, unique), save all tags (creating any that don't exist), and return the new slug. `UpdatePost` should update fields, handle tag changes, and reject updates to others' posts.
2. Implement `AddCommentCommand` that inserts a comment as unapproved, and a `ApproveCommentCommand` (admin only) that marks it approved. Add a `GET /api/blog/posts/{slug}/comments` endpoint returning approved comments in threaded structure.
3. Add a `GET /api/blog/analytics/top-posts?days=30` endpoint using a CQRS query handler. The SQL should return the top 10 posts by view count in the last N days, with their tag names. Verify it's a single SQL query by logging the connection.
4. Write integration tests using SQLite in-memory: test that (a) creating and publishing a post works end-to-end via commands, (b) the view count increments on each `GetPostQuery` call, (c) unpublished posts are excluded from `ListPostsQuery`.
</ExerciseBlock>
