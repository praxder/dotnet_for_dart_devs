---
title: "Dapper: Connection Management and IDbConnectionFactory"
day: 101
week: 21
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "database connection management in Dart, connection pooling"
csharpConcept: "IDbConnectionFactory, connection pooling, multiple databases, open/close lifecycle"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Connection management is one area where Dapper requires more thought than EF Core. EF Core's `DbContext` manages connections internally; with Dapper, you manage them explicitly. Done right, this gives you fine-grained control and excellent performance.

## How Connection Pooling Works

```csharp
// When you call new SqlConnection(connString).Open():
// ADO.NET checks its internal connection pool for a matching idle connection.
// If found: reuses it (fast — no TCP handshake)
// If not: opens a new physical connection (slower)

// When you call conn.Close() or conn.Dispose():
// The connection returns to the pool — it's NOT actually closed.
// The pool keeps it ready for the next request.

// This means: opening and closing connections frequently is FINE.
// The "open once, reuse" pattern from older code is unnecessary.

// ✅ Modern pattern: create per-method, let using statement dispose it
public async Task<Product?> GetByIdAsync(int id)
{
    using var conn = factory.CreateConnection();  // checks pool
    // conn is automatically opened by Dapper's QueryAsync
    return await conn.QueryFirstOrDefaultAsync<Product>(
        "SELECT * FROM products WHERE id = @Id", new { Id = id });
    // Dispose() → returns to pool
}
```

## The IDbConnectionFactory Pattern

```csharp
// Define the factory interface
public interface IDbConnectionFactory
{
    IDbConnection CreateConnection();
    Task<IDbConnection> CreateOpenConnectionAsync(CancellationToken ct = default);
}

// SQLite implementation
public class SqliteConnectionFactory : IDbConnectionFactory
{
    private readonly string _connectionString;

    public SqliteConnectionFactory(string connectionString)
        => _connectionString = connectionString;

    public IDbConnection CreateConnection()
        => new SqliteConnection(_connectionString);

    public async Task<IDbConnection> CreateOpenConnectionAsync(CancellationToken ct = default)
    {
        var conn = new SqliteConnection(_connectionString);
        await conn.OpenAsync(ct);
        return conn;
    }
}

// SQL Server implementation
public class SqlServerConnectionFactory : IDbConnectionFactory
{
    private readonly string _connectionString;

    public SqlServerConnectionFactory(string connectionString)
        => _connectionString = connectionString;

    public IDbConnection CreateConnection()
        => new SqlConnection(_connectionString);

    public async Task<IDbConnection> CreateOpenConnectionAsync(CancellationToken ct = default)
    {
        var conn = new SqlConnection(_connectionString);
        await conn.OpenAsync(ct);
        return conn;
    }
}

// Registration:
builder.Services.AddSingleton<IDbConnectionFactory>(provider =>
{
    var connStr = builder.Configuration.GetConnectionString("Default")!;
    // Switch on environment or config:
    return new SqliteConnectionFactory(connStr);
    // return new SqlServerConnectionFactory(connStr);
});
```

## Multiple Databases

```csharp
// When your app connects to multiple databases, use named factories

public interface IReadDbConnectionFactory : IDbConnectionFactory { }
public interface IWriteDbConnectionFactory : IDbConnectionFactory { }

// Read replica for queries, primary for writes
public class ReadDbConnectionFactory(string connStr)
    : SqlServerConnectionFactory(connStr), IReadDbConnectionFactory { }

public class WriteDbConnectionFactory(string connStr)
    : SqlServerConnectionFactory(connStr), IWriteDbConnectionFactory { }

// Registration:
builder.Services.AddSingleton<IReadDbConnectionFactory>(
    new ReadDbConnectionFactory(
        builder.Configuration.GetConnectionString("ReadReplica")!));

builder.Services.AddSingleton<IWriteDbConnectionFactory>(
    new WriteDbConnectionFactory(
        builder.Configuration.GetConnectionString("Primary")!));

// Repository using both:
public class OrderRepository(
    IReadDbConnectionFactory readFactory,
    IWriteDbConnectionFactory writeFactory)
{
    public async Task<IEnumerable<Order>> GetAllAsync()
    {
        using var conn = readFactory.CreateConnection();  // goes to read replica
        return await conn.QueryAsync<Order>("SELECT * FROM orders");
    }

    public async Task<int> CreateAsync(Order order)
    {
        using var conn = writeFactory.CreateConnection();  // goes to primary
        return await conn.QuerySingleAsync<int>(
            "INSERT INTO orders ... ; SELECT SCOPE_IDENTITY()", order);
    }
}
```

## Connection Configuration — Tuning the Pool

```csharp
// Connection string parameters control the pool
// SQL Server:
var connStr = new SqlConnectionStringBuilder
{
    DataSource = "myserver",
    InitialCatalog = "mydb",
    IntegratedSecurity = false,
    UserID = "appuser",
    Password = "...",
    MinPoolSize = 5,          // keep 5 connections ready
    MaxPoolSize = 100,        // max 100 concurrent connections
    ConnectTimeout = 30,      // seconds to wait for a connection
    CommandTimeout = 30,      // default command timeout
    Pooling = true,           // enable pooling (default: true)
    ApplicationName = "MyApp" // visible in SQL Server monitoring
}.ConnectionString;

// SQLite:
var sqliteConnStr = new SqliteConnectionStringBuilder
{
    DataSource = "myapp.db",
    Cache = SqliteCacheMode.Shared,  // shared cache for in-process concurrency
    Mode = SqliteOpenMode.ReadWriteCreate
}.ConnectionString;
```

## Managing Connection Lifetime in Background Services

```csharp
// Background services run outside the HTTP request lifecycle
// Don't inject Scoped services; use the factory directly

public class OrderProcessingService(
    IDbConnectionFactory factory,
    ILogger<OrderProcessingService> logger) : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await ProcessBatchAsync(stoppingToken);
            await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken);
        }
    }

    private async Task ProcessBatchAsync(CancellationToken ct)
    {
        // Open one connection for the whole batch (transaction scope)
        using var conn = await factory.CreateOpenConnectionAsync(ct);
        await using var tx = await conn.BeginTransactionAsync(ct);

        try
        {
            var pending = await conn.QueryAsync<Order>(
                "SELECT * FROM orders WHERE status = 'Pending' LIMIT 50",
                transaction: tx);

            foreach (var order in pending)
            {
                await conn.ExecuteAsync(
                    "UPDATE orders SET status = 'Processing' WHERE id = @Id",
                    new { order.Id },
                    transaction: tx);

                // ... process each order ...
            }

            await tx.CommitAsync(ct);
            logger.LogInformation("Processed {Count} orders", pending.Count());
        }
        catch (Exception ex)
        {
            await tx.RollbackAsync(ct);
            logger.LogError(ex, "Batch processing failed");
        }
    }
}
```

## Detecting Connection Leaks

```csharp
// Wrapping the connection factory to detect open connections in production

#if DEBUG
public class DiagnosticConnectionFactory(IDbConnectionFactory inner) : IDbConnectionFactory
{
    private int _openCount;

    public IDbConnection CreateConnection()
    {
        Interlocked.Increment(ref _openCount);
        var conn = inner.CreateConnection();
        return new DiagnosticConnection(conn, () => Interlocked.Decrement(ref _openCount));
    }

    public int OpenConnectionCount => _openCount;
}
#endif

// Log pool metrics at startup or in health checks:
public class DatabaseHealthCheck(IDbConnectionFactory factory) : IHealthCheck
{
    public async Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context, CancellationToken ct)
    {
        try
        {
            using var conn = factory.CreateConnection();
            var result = await conn.ExecuteScalarAsync<int>("SELECT 1");
            return HealthCheckResult.Healthy("Database is reachable");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Database unreachable", ex);
        }
    }
}
```

<ConceptCallout type="tip" title="Keep Connections Short-Lived">
The best practice with Dapper: open a connection, do your work, dispose immediately. For transactions, open once, do all work, commit/rollback, dispose. Don't hold connections open across multiple unrelated operations — the pool handles reuse efficiently behind the scenes.
</ConceptCallout>

<ExerciseBlock>
1. Implement `IDbConnectionFactory` with both SQLite and SQL Server variants. In Program.cs, switch between them based on the environment: SQLite for Development, SQL Server for Staging/Production. Verify by running in both modes.
2. Set up a read replica pattern: configure two connection strings in appsettings.json (`ReadReplica` and `Primary`). Create `IReadDbConnectionFactory` and `IWriteDbConnectionFactory`. Update `ProductRepository` to use reads on the replica and writes on primary.
3. Add a health check endpoint `GET /health` that verifies the database is reachable using `IDbConnectionFactory`. Return the connection time in milliseconds. Register it with `builder.Services.AddHealthChecks()` and map it with `app.MapHealthChecks("/health")`.
</ExerciseBlock>
