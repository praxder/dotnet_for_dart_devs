---
title: "Capstone: Full Blog API with Dapper"
day: 105
week: 21
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "production-grade Flutter API backend, sqflite data layer"
csharpConcept: "Dapper + CQRS + MediatR + type handlers + transactions + testing, complete API"
estimatedMinutes: 60
isProject: true
projectType: "mini"
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

This is the Module 8 capstone. You'll integrate everything from the Dapper module into a production-quality blog API: connection factory, CRUD repositories, multi-mapping, transactions, CQRS with MediatR, dynamic queries, type handlers, and integration tests.

## Architecture Overview

```
┌──────────────────────────────────────────────────────┐
│                  ASP.NET Core API                      │
│                                                        │
│  Minimal API Endpoints                                 │
│        │                                               │
│        ▼                                               │
│  MediatR Pipeline                                      │
│   ├── ValidationBehavior (FluentValidation)            │
│   └── LoggingBehavior (request/response timing)        │
│        │                                               │
│  Command / Query Handlers                              │
│   ├── Commands → IDbConnectionFactory + transactions   │
│   └── Queries  → IDbConnectionFactory + SqlBuilder    │
│        │                                               │
│        ▼                                               │
│  Dapper (IDbConnection extensions)                     │
│   ├── TypeHandlers (enums, JSON, DateTimeOffset)       │
│   └── MultiMapping (JOINs, QueryMultiple)              │
│        │                                               │
│        ▼                                               │
│   SQLite / SQL Server                                  │
└──────────────────────────────────────────────────────┘
```

## DapperConfiguration — Centralized Setup

```csharp
// Run once at startup before any Dapper calls
public static class DapperConfiguration
{
    public static void Configure()
    {
        DefaultTypeMap.MatchNamesWithUnderscores = true;

        SqlMapper.AddTypeHandler(new EnumTypeHandler<PostStatus>());
        SqlMapper.AddTypeHandler(new EnumTypeHandler<CommentStatus>());
        SqlMapper.AddTypeHandler(new JsonTypeHandler<PostSeo>());
        SqlMapper.AddTypeHandler(new DateTimeOffsetHandler());
        SqlMapper.AddTypeHandler(new NullableDateTimeOffsetHandler());
    }
}

// In Program.cs:
DapperConfiguration.Configure();
builder.Services.AddSingleton<IDbConnectionFactory>(
    new SqliteConnectionFactory(builder.Configuration.GetConnectionString("Default")!));
```

## Domain Models

```csharp
public enum PostStatus  { Draft, Published, Archived }
public enum CommentStatus { Pending, Approved, Rejected }

public class Author
{
    public int Id { get; set; }
    public string Name { get; set; } = "";
    public string Email { get; set; } = "";
    public string Bio { get; set; } = "";
    public string? AvatarUrl { get; set; }
    public DateTimeOffset JoinedAt { get; set; }
    public bool IsActive { get; set; }
}

public class Post
{
    public int Id { get; set; }
    public string Title { get; set; } = "";
    public string Slug { get; set; } = "";
    public string Summary { get; set; } = "";
    public string Body { get; set; } = "";
    public PostStatus Status { get; set; } = PostStatus.Draft;
    public int ViewCount { get; set; }
    public int AuthorId { get; set; }
    public DateTimeOffset? PublishedAt { get; set; }
    public DateTimeOffset CreatedAt { get; set; }
    public DateTimeOffset UpdatedAt { get; set; }
    public PostSeo Seo { get; set; } = new();
}

public class PostSeo
{
    public string? MetaTitle { get; set; }
    public string? MetaDescription { get; set; }
    public List<string> Keywords { get; set; } = [];
}
```

## Repositories

```csharp
public interface IPostRepository
{
    Task<Post?> GetBySlugAsync(string slug);
    Task<Post?> GetByIdAsync(int id);
    Task<int> CreateAsync(Post post, IEnumerable<int> tagIds);
    Task<bool> UpdateAsync(Post post, IEnumerable<int> tagIds);
    Task<bool> PublishAsync(int postId, int authorId);
    Task<bool> DeleteAsync(int id);
    Task IncrementViewCountAsync(int id);
}

public class PostRepository(IDbConnectionFactory factory) : IPostRepository
{
    public async Task<Post?> GetBySlugAsync(string slug)
    {
        using var conn = factory.CreateConnection();
        return await conn.QueryFirstOrDefaultAsync<Post>(
            @"SELECT id, title, slug, summary, body, status, view_count,
                     author_id, published_at, created_at, updated_at, seo
              FROM posts
              WHERE slug = @Slug AND status = 'Published'",
            new { Slug = slug });
        // 'status' maps to PostStatus enum via EnumTypeHandler
        // 'seo' maps to PostSeo via JsonTypeHandler
    }

    public async Task<int> CreateAsync(Post post, IEnumerable<int> tagIds)
    {
        using var conn = factory.CreateConnection();
        await conn.OpenAsync();
        await using var tx = await conn.BeginTransactionAsync();

        try
        {
            var postId = await conn.QuerySingleAsync<int>(@"
                INSERT INTO posts (title, slug, summary, body, status,
                                   author_id, created_at, updated_at, seo)
                VALUES (@Title, @Slug, @Summary, @Body, @Status,
                        @AuthorId, @CreatedAt, @UpdatedAt, @Seo);
                SELECT last_insert_rowid();",
                post, transaction: tx);

            var tagIdList = tagIds.ToList();
            if (tagIdList.Count > 0)
            {
                await conn.ExecuteAsync(
                    "INSERT INTO post_tags (post_id, tag_id) VALUES (@PostId, @TagId)",
                    tagIdList.Select(tagId => new { PostId = postId, TagId = tagId }),
                    transaction: tx);
            }

            await tx.CommitAsync();
            return postId;
        }
        catch
        {
            await tx.RollbackAsync();
            throw;
        }
    }

    public async Task<bool> PublishAsync(int postId, int authorId)
    {
        using var conn = factory.CreateConnection();
        var affected = await conn.ExecuteAsync(@"
            UPDATE posts
            SET status       = 'Published',
                published_at = @Now,
                updated_at   = @Now
            WHERE id        = @PostId
              AND author_id = @AuthorId
              AND status    = 'Draft'",
            new { PostId = postId, AuthorId = authorId, Now = DateTimeOffset.UtcNow });
        return affected > 0;
    }

    public async Task IncrementViewCountAsync(int id)
    {
        using var conn = factory.CreateConnection();
        await conn.ExecuteAsync(
            "UPDATE posts SET view_count = view_count + 1 WHERE id = @Id",
            new { Id = id });
    }

    // ... remaining methods ...
}
```

## CQRS Handlers

```csharp
// Optimized list query using SqlBuilder
public record ListPostsQuery(
    string? Tag = null,
    string? Search = null,
    int Page = 1,
    int PageSize = 20) : IRequest<PagedResult<PostSummaryDto>>;

public class ListPostsHandler(IDbConnectionFactory factory)
    : IRequestHandler<ListPostsQuery, PagedResult<PostSummaryDto>>
{
    public async Task<PagedResult<PostSummaryDto>> Handle(
        ListPostsQuery request, CancellationToken ct)
    {
        using var conn = factory.CreateConnection();
        var builder = new SqlBuilder();

        var dataTemplate = builder.AddTemplate(@"
            SELECT p.id, p.title, p.slug, p.summary,
                   a.name AS AuthorName, p.published_at, p.view_count,
                   COUNT(DISTINCT c.id) AS CommentCount
            FROM posts p
            INNER JOIN authors a ON a.id = p.author_id
            LEFT JOIN comments c ON c.post_id = p.id AND c.status = 'Approved'
            /**join**/
            /**where**/
            GROUP BY p.id, p.title, p.slug, p.summary, a.name, p.published_at, p.view_count
            ORDER BY p.published_at DESC
            LIMIT @Limit OFFSET @Offset",
            new { Limit = request.PageSize, Offset = (request.Page - 1) * request.PageSize });

        var countTemplate = builder.AddTemplate(@"
            SELECT COUNT(DISTINCT p.id)
            FROM posts p
            /**join**/
            /**where**/");

        builder.Where("p.status = 'Published'");

        if (request.Tag is not null)
        {
            builder.Join("post_tags pt ON pt.post_id = p.id");
            builder.Join("tags t ON t.id = pt.tag_id");
            builder.Where("t.slug = @Tag", new { request.Tag });
        }

        if (request.Search is { Length: > 0 } s)
            builder.Where("(p.title LIKE @Search OR p.summary LIKE @Search)",
                new { Search = $"%{s}%" });

        using var multi = await conn.QueryMultipleAsync(
            dataTemplate.RawSql + "; " + countTemplate.RawSql,
            dataTemplate.Parameters);

        var posts = (await multi.ReadAsync<PostSummaryDto>()).ToList();
        var total = await multi.ReadSingleAsync<int>();

        // Enrich with tags (avoids Cartesian product)
        if (posts.Count > 0)
        {
            var postIds = posts.Select(p => p.Id).ToList();
            var tagRows = await conn.QueryAsync(@"
                SELECT pt.post_id AS PostId, t.name AS TagName
                FROM post_tags pt
                INNER JOIN tags t ON t.id = pt.tag_id
                WHERE pt.post_id IN @Ids",
                new { Ids = postIds });

            var tagsByPost = tagRows
                .GroupBy(r => (int)r.PostId)
                .ToDictionary(g => g.Key, g => g.Select(r => (string)r.TagName).ToList());

            // Update post summaries with their tags
            posts = posts.Select(p => p with
            {
                Tags = tagsByPost.GetValueOrDefault(p.Id, [])
            }).ToList();
        }

        return new PagedResult<PostSummaryDto>(posts, total, request.Page, request.PageSize);
    }
}
```

## API Registration

```csharp
var blog = app.MapGroup("/api/blog").WithOpenApi();

// Public
blog.MapGet("/posts",         ([AsParameters] ListPostsQuery q, IMediator m) => m.Send(q));
blog.MapGet("/posts/{slug}",  (string slug, IMediator m) => m.Send(new GetPostQuery(slug)));
blog.MapGet("/tags",          (IMediator m) => m.Send(new ListTagsQuery()));
blog.MapGet("/analytics/top", (IMediator m) => m.Send(new GetTopPostsQuery(Days: 30)));

// Authenticated (author)
var admin = blog.MapGroup("/admin").RequireAuthorization("author");
admin.MapPost("/posts",             (CreatePostCommand cmd, IMediator m) => m.Send(cmd));
admin.MapPut("/posts/{id:int}",     (int id, UpdatePostCommand cmd, IMediator m) => m.Send(cmd with { PostId = id }));
admin.MapDelete("/posts/{id:int}",  (int id, IMediator m, ClaimsPrincipal u) =>
    m.Send(new DeletePostCommand(id, GetUserId(u))));
admin.MapPost("/posts/{id:int}/publish", (int id, IMediator m, ClaimsPrincipal u) =>
    m.Send(new PublishPostCommand(id, GetUserId(u))));
```

<ExerciseBlock>
1. **Complete all handlers**: implement `GetPostQuery`, `CreatePostCommand`, `UpdatePostCommand`, `DeletePostCommand`, and `GetTopPostsQuery`. Every command handler must use a transaction. Every query handler must use `SqlBuilder` for filtering. All handlers inject `IDbConnectionFactory`.
2. **Tag management**: `CreatePostCommand` should accept a list of tag names. For each tag, find or create it (using upsert on the `slug`). Link the post to all tags in a single batched `INSERT INTO post_tags`. Update `UpdatePostCommand` to replace the post's tags atomically.
3. **Analytics endpoint**: `GET /api/blog/analytics/top-posts?days=30` returns the top 10 posts by view count, grouped with their tag names as a comma-separated string (SQLite `GROUP_CONCAT` or SQL Server `STRING_AGG`). Verify the endpoint returns in under 100ms with 50,000 posts seeded.
4. **Integration test suite**: using SQLite in-memory, write tests covering the full lifecycle: create author → create post → publish post → verify in listing → get by slug → increment view count → delete → verify gone. Each test step should go through the MediatR pipeline (not repository directly).
</ExerciseBlock>
