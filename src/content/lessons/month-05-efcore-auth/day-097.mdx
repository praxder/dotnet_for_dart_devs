---
title: "Dapper: Repository Pattern"
day: 97
week: 20
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "repository pattern in Dart, data layer abstraction"
csharpConcept: "IRepository<T>, IDbConnectionFactory, Unit of Work with Dapper, testability"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

The repository pattern abstracts data access behind an interface. With Dapper, repositories are simpler than with EF Core — no change tracking, no `SaveChanges`, just methods that run SQL. This makes them easy to write, test, and understand.

## IDbConnectionFactory — Injecting Connections Cleanly

```csharp
// Instead of injecting IConfiguration and creating connections manually everywhere,
// register a connection factory in DI.

public interface IDbConnectionFactory
{
    IDbConnection CreateConnection();
}

public class SqliteConnectionFactory(string connectionString) : IDbConnectionFactory
{
    public IDbConnection CreateConnection()
        => new SqliteConnection(connectionString);
}

// SQL Server version:
public class SqlServerConnectionFactory(string connectionString) : IDbConnectionFactory
{
    public IDbConnection CreateConnection()
        => new SqlConnection(connectionString);
}

// Registration in Program.cs:
builder.Services.AddSingleton<IDbConnectionFactory>(
    new SqliteConnectionFactory(
        builder.Configuration.GetConnectionString("Default")!));
```

## Generic Repository Interface

```csharp
// A simple generic interface — keep it minimal
public interface IRepository<T, TKey> where T : class
{
    Task<T?> GetByIdAsync(TKey id);
    Task<IEnumerable<T>> GetAllAsync();
    Task<TKey> CreateAsync(T entity);
    Task<bool> UpdateAsync(T entity);
    Task<bool> DeleteAsync(TKey id);
}
```

## Concrete Repository Implementation

```csharp
public interface IProductRepository : IRepository<Product, int>
{
    // Domain-specific queries beyond basic CRUD
    Task<IEnumerable<Product>> GetActiveByCategoryAsync(int categoryId);
    Task<IEnumerable<Product>> SearchAsync(string nameContains);
    Task<bool> UpdateStockAsync(int id, int newQuantity);
}

public class ProductRepository(IDbConnectionFactory factory) : IProductRepository
{
    // ─── READ ───────────────────────────────────────────────────────

    public async Task<Product?> GetByIdAsync(int id)
    {
        using var conn = factory.CreateConnection();
        return await conn.QueryFirstOrDefaultAsync<Product>(
            "SELECT id, name, price, category_id, stock_quantity, is_active FROM products WHERE id = @Id",
            new { Id = id });
    }

    public async Task<IEnumerable<Product>> GetAllAsync()
    {
        using var conn = factory.CreateConnection();
        return await conn.QueryAsync<Product>(
            "SELECT id, name, price, category_id, stock_quantity, is_active FROM products ORDER BY name");
    }

    public async Task<IEnumerable<Product>> GetActiveByCategoryAsync(int categoryId)
    {
        using var conn = factory.CreateConnection();
        return await conn.QueryAsync<Product>(
            @"SELECT id, name, price, category_id, stock_quantity, is_active
              FROM products
              WHERE category_id = @CategoryId AND is_active = 1
              ORDER BY name",
            new { CategoryId = categoryId });
    }

    public async Task<IEnumerable<Product>> SearchAsync(string nameContains)
    {
        using var conn = factory.CreateConnection();
        return await conn.QueryAsync<Product>(
            "SELECT * FROM products WHERE name LIKE @Pattern AND is_active = 1",
            new { Pattern = $"%{nameContains}%" });
    }

    // ─── WRITE ──────────────────────────────────────────────────────

    public async Task<int> CreateAsync(Product product)
    {
        using var conn = factory.CreateConnection();
        return await conn.QuerySingleAsync<int>(@"
            INSERT INTO products (name, price, category_id, stock_quantity, is_active)
            VALUES (@Name, @Price, @CategoryId, @StockQuantity, @IsActive);
            SELECT last_insert_rowid();",
            product);
    }

    public async Task<bool> UpdateAsync(Product product)
    {
        using var conn = factory.CreateConnection();
        var affected = await conn.ExecuteAsync(@"
            UPDATE products
            SET name           = @Name,
                price          = @Price,
                category_id    = @CategoryId,
                stock_quantity = @StockQuantity,
                is_active      = @IsActive
            WHERE id = @Id",
            product);
        return affected > 0;
    }

    public async Task<bool> UpdateStockAsync(int id, int newQuantity)
    {
        using var conn = factory.CreateConnection();
        var affected = await conn.ExecuteAsync(
            "UPDATE products SET stock_quantity = @Qty WHERE id = @Id",
            new { Qty = newQuantity, Id = id });
        return affected > 0;
    }

    public async Task<bool> DeleteAsync(int id)
    {
        using var conn = factory.CreateConnection();
        var affected = await conn.ExecuteAsync(
            "DELETE FROM products WHERE id = @Id",
            new { Id = id });
        return affected > 0;
    }
}

// Registration:
builder.Services.AddScoped<IProductRepository, ProductRepository>();
```

## Repository With Transactions — Unit of Work Pattern

```csharp
// When multiple repositories need to share a transaction,
// use a Unit of Work that owns the connection and transaction.

public interface IUnitOfWork : IAsyncDisposable
{
    IProductRepository Products { get; }
    IOrderRepository Orders { get; }
    Task BeginAsync();
    Task CommitAsync();
    Task RollbackAsync();
}

public class UnitOfWork : IUnitOfWork
{
    private readonly IDbConnection _conn;
    private IDbTransaction? _tx;

    public UnitOfWork(IDbConnectionFactory factory)
    {
        _conn = factory.CreateConnection();
        _conn.Open();

        // Repositories share the same open connection
        Products = new ProductRepository(_conn);
        Orders   = new OrderRepository(_conn);
    }

    public IProductRepository Products { get; }
    public IOrderRepository Orders { get; }

    public Task BeginAsync()
    {
        _tx = _conn.BeginTransaction();
        // Pass transaction to repositories
        ((ProductRepository)Products).SetTransaction(_tx);
        ((OrderRepository)Orders).SetTransaction(_tx);
        return Task.CompletedTask;
    }

    public async Task CommitAsync()
    {
        if (_tx is null) throw new InvalidOperationException("No active transaction");
        await _tx.CommitAsync();
        _tx = null;
    }

    public async Task RollbackAsync()
    {
        if (_tx is not null)
        {
            await _tx.RollbackAsync();
            _tx = null;
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_tx is not null) await _tx.DisposeAsync();
        if (_conn.State == ConnectionState.Open) _conn.Close();
        _conn.Dispose();
    }
}
```

<ConceptCallout type="tip" title="Simple Repositories vs Unit of Work">
For most operations (single-repository calls), you don't need a Unit of Work — just `using var conn = factory.CreateConnection()` in each repository method. Use the Unit of Work pattern only when you need coordinated multi-repository transactions. Keep the default case simple.
</ConceptCallout>

## Testing Repositories

```csharp
// Option 1: Fake repository (pure in-memory, no database)
public class FakeProductRepository : IProductRepository
{
    private readonly List<Product> _products = [];
    private int _nextId = 1;

    public Task<Product?> GetByIdAsync(int id)
        => Task.FromResult(_products.FirstOrDefault(p => p.Id == id));

    public Task<IEnumerable<Product>> GetAllAsync()
        => Task.FromResult<IEnumerable<Product>>(_products.ToList());

    public Task<IEnumerable<Product>> GetActiveByCategoryAsync(int categoryId)
        => Task.FromResult<IEnumerable<Product>>(
            _products.Where(p => p.CategoryId == categoryId && p.IsActive).ToList());

    public Task<IEnumerable<Product>> SearchAsync(string nameContains)
        => Task.FromResult<IEnumerable<Product>>(
            _products.Where(p => p.Name.Contains(nameContains, StringComparison.OrdinalIgnoreCase)).ToList());

    public Task<int> CreateAsync(Product product)
    {
        product.Id = _nextId++;
        _products.Add(product);
        return Task.FromResult(product.Id);
    }

    public Task<bool> UpdateAsync(Product product)
    {
        var index = _products.FindIndex(p => p.Id == product.Id);
        if (index < 0) return Task.FromResult(false);
        _products[index] = product;
        return Task.FromResult(true);
    }

    public Task<bool> UpdateStockAsync(int id, int newQuantity)
    {
        var product = _products.FirstOrDefault(p => p.Id == id);
        if (product is null) return Task.FromResult(false);
        product.StockQuantity = newQuantity;
        return Task.FromResult(true);
    }

    public Task<bool> DeleteAsync(int id)
    {
        var product = _products.FirstOrDefault(p => p.Id == id);
        if (product is null) return Task.FromResult(false);
        _products.Remove(product);
        return Task.FromResult(true);
    }

    // Test helper: seed data
    public void Seed(params Product[] products)
    {
        foreach (var p in products)
        {
            p.Id = _nextId++;
            _products.Add(p);
        }
    }
}

// Unit test using fake (no database):
[Fact]
public async Task GetActiveByCategoryAsync_ReturnsOnlyActiveProducts()
{
    var repo = new FakeProductRepository();
    repo.Seed(
        new Product { Name = "Active Widget", CategoryId = 1, IsActive = true },
        new Product { Name = "Inactive Gadget", CategoryId = 1, IsActive = false },
        new Product { Name = "Other Category", CategoryId = 2, IsActive = true }
    );

    var results = await repo.GetActiveByCategoryAsync(1);

    Assert.Single(results);
    Assert.Equal("Active Widget", results.First().Name);
}
```

<ExerciseBlock>
1. Create an `IDbConnectionFactory`, register it in DI, and update `ProductRepository` and `CustomerRepository` to inject it instead of `IConfiguration`. Verify they still work end-to-end through your API.
2. Build `IOrderRepository` and `OrderRepository` with: `GetByIdAsync`, `GetByCustomerAsync(int customerId)`, `GetByStatusAsync(string status)`, `CreateAsync(Order)` (returns new ID), `UpdateStatusAsync(int id, string newStatus)`. Register and wire it to your Minimal API order endpoints.
3. Write a `FakeOrderRepository` and use it to unit-test an `OrderService.CancelOrderAsync(int orderId)` method that: fetches the order, checks it's in a cancellable state (Pending or Processing), updates status to Cancelled, and returns the cancelled order. No database required in the test.
</ExerciseBlock>
