---
title: "Dapper: CQRS and MediatR"
day: 98
week: 20
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "BLoC pattern in Flutter, command/event separation"
csharpConcept: "CQRS, MediatR, IRequest<T>, IRequestHandler, pipeline behaviors, Dapper in handlers"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

CQRS (Command Query Responsibility Segregation) separates reads from writes. With MediatR, each operation becomes a self-contained request + handler class. Dapper fits naturally here: query handlers run optimized `SELECT` SQL, command handlers run `INSERT`/`UPDATE`/`DELETE` with transactions.

## CQRS with Dapper vs EF Core

<CodeComparison>
  <div slot="dart">
  ```dart
  // Flutter BLoC — similar concept:
  // Events = Commands, States = Query Results
  class OrderBloc extends Bloc<OrderEvent, OrderState> {
    final OrderRepository _repo;
    OrderBloc(this._repo) : super(OrderInitial()) {
      on<PlaceOrderEvent>(_onPlaceOrder);
      on<LoadOrderEvent>(_onLoadOrder);
    }
  }
  ```
  </div>
  <div slot="csharp">
  ```csharp
  // CQRS with MediatR — each request is a separate class
  // Commands use Dapper for writes + transactions
  // Queries use Dapper for optimized SELECT SQL

  public record PlaceOrderCommand(int CustomerId, List<OrderItemDto> Items)
      : IRequest<int>;  // returns new order ID

  public record GetOrderQuery(int OrderId)
      : IRequest<OrderDetailDto?>;
  ```
  </div>
</CodeComparison>

## Setup

```bash
dotnet add package MediatR
```

```csharp
// Program.cs
builder.Services.AddMediatR(cfg =>
    cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));

// Register connection factory (from day 97)
builder.Services.AddSingleton<IDbConnectionFactory>(
    new SqliteConnectionFactory(builder.Configuration.GetConnectionString("Default")!));
```

## Command Handler — Write Side

```csharp
// Command: intent to change state
public record PlaceOrderCommand(
    int CustomerId,
    List<OrderItemDto> Items) : IRequest<PlaceOrderResult>;

public record PlaceOrderResult(int OrderId, decimal Total);
public record OrderItemDto(int ProductId, int Quantity, decimal UnitPrice);

// Handler: all business logic for this operation, uses Dapper directly
public class PlaceOrderCommandHandler(IDbConnectionFactory factory)
    : IRequestHandler<PlaceOrderCommand, PlaceOrderResult>
{
    public async Task<PlaceOrderResult> Handle(
        PlaceOrderCommand request,
        CancellationToken ct)
    {
        using var conn = factory.CreateConnection();
        await conn.OpenAsync(ct);
        await using var tx = await conn.BeginTransactionAsync(ct);

        try
        {
            // Validate and reserve inventory
            foreach (var item in request.Items)
            {
                var affected = await conn.ExecuteAsync(@"
                    UPDATE products
                    SET stock_quantity = stock_quantity - @Qty
                    WHERE id = @ProductId AND stock_quantity >= @Qty",
                    new { Qty = item.Quantity, item.ProductId },
                    transaction: tx);

                if (affected == 0)
                    throw new InsufficientStockException(item.ProductId);
            }

            // Create order
            var total = request.Items.Sum(i => i.Quantity * i.UnitPrice);
            var orderId = await conn.QuerySingleAsync<int>(@"
                INSERT INTO orders (customer_id, total, status, ordered_at)
                VALUES (@CustomerId, @Total, 'Pending', @Now);
                SELECT last_insert_rowid();",
                new { request.CustomerId, Total = total, Now = DateTime.UtcNow },
                transaction: tx);

            // Create order lines
            await conn.ExecuteAsync(@"
                INSERT INTO order_lines (order_id, product_id, quantity, unit_price)
                VALUES (@OrderId, @ProductId, @Quantity, @UnitPrice)",
                request.Items.Select(i => new
                {
                    OrderId = orderId,
                    i.ProductId,
                    i.Quantity,
                    i.UnitPrice
                }),
                transaction: tx);

            await tx.CommitAsync(ct);
            return new PlaceOrderResult(orderId, total);
        }
        catch
        {
            await tx.RollbackAsync(ct);
            throw;
        }
    }
}
```

## Query Handler — Read Side

```csharp
// Query: read-only, returns a DTO — no transaction needed
public record GetOrderQuery(int OrderId) : IRequest<OrderDetailDto?>;

public record OrderDetailDto(
    int Id,
    string CustomerName,
    string Status,
    decimal Total,
    DateTime OrderedAt,
    List<OrderLineDto> Lines);

public record OrderLineDto(
    string ProductName,
    int Quantity,
    decimal UnitPrice,
    decimal LineTotal);

public class GetOrderQueryHandler(IDbConnectionFactory factory)
    : IRequestHandler<GetOrderQuery, OrderDetailDto?>
{
    public async Task<OrderDetailDto?> Handle(GetOrderQuery request, CancellationToken ct)
    {
        using var conn = factory.CreateConnection();

        // Use QueryMultiple for a single round trip
        using var multi = await conn.QueryMultipleAsync(@"
            SELECT o.id, c.name AS CustomerName, o.status, o.total, o.ordered_at
            FROM orders o
            INNER JOIN customers c ON c.id = o.customer_id
            WHERE o.id = @OrderId;

            SELECT p.name AS ProductName, ol.quantity, ol.unit_price,
                   ol.quantity * ol.unit_price AS LineTotal
            FROM order_lines ol
            INNER JOIN products p ON p.id = ol.product_id
            WHERE ol.order_id = @OrderId
            ORDER BY ol.id;",
            new { OrderId = request.OrderId });

        var order = await multi.ReadFirstOrDefaultAsync<dynamic>();
        if (order is null) return null;

        var lines = (await multi.ReadAsync<OrderLineDto>()).ToList();

        return new OrderDetailDto(
            order.id,
            order.CustomerName,
            order.status,
            order.total,
            order.ordered_at,
            lines);
    }
}
```

## Using MediatR in Minimal APIs

```csharp
var orders = app.MapGroup("/api/orders");

orders.MapPost("/", async (PlaceOrderCommand command, IMediator mediator) =>
{
    var result = await mediator.Send(command);
    return Results.Created($"/api/orders/{result.OrderId}", result);
});

orders.MapGet("/{id:int}", async (int id, IMediator mediator) =>
{
    var order = await mediator.Send(new GetOrderQuery(id));
    return order is null ? Results.NotFound() : Results.Ok(order);
});
```

## Pipeline Behaviors — Cross-Cutting Concerns

```csharp
// Behaviors wrap every MediatR request — logging, validation, timing
// Works exactly the same regardless of whether handlers use Dapper or EF Core

// Logging behavior:
public class LoggingBehavior<TRequest, TResponse>(
    ILogger<LoggingBehavior<TRequest, TResponse>> logger)
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken ct)
    {
        logger.LogInformation("→ {Request}: {@Data}", typeof(TRequest).Name, request);
        var sw = Stopwatch.StartNew();

        var response = await next();

        logger.LogInformation("← {Request} completed in {Elapsed}ms",
            typeof(TRequest).Name, sw.ElapsedMilliseconds);
        return response;
    }
}

// Register (order = outermost first):
builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
```

## Read-Optimized Queries — The Real CQRS Win

```csharp
// The read side can use a completely different SQL shape than the write model
// No entity classes needed — project directly to DTOs

public record ListOrdersQuery(
    int? CustomerId = null,
    string? Status = null,
    int Page = 1,
    int PageSize = 20) : IRequest<PagedResult<OrderSummaryDto>>;

public record OrderSummaryDto(
    int Id,
    string CustomerName,
    int LineCount,
    decimal Total,
    string Status,
    DateTime OrderedAt);

public class ListOrdersHandler(IDbConnectionFactory factory)
    : IRequestHandler<ListOrdersQuery, PagedResult<OrderSummaryDto>>
{
    public async Task<PagedResult<OrderSummaryDto>> Handle(ListOrdersQuery request, CancellationToken ct)
    {
        using var conn = factory.CreateConnection();

        var conditions = new List<string>();
        var parameters = new DynamicParameters();

        if (request.CustomerId.HasValue)
        {
            conditions.Add("o.customer_id = @CustomerId");
            parameters.Add("@CustomerId", request.CustomerId.Value);
        }

        if (!string.IsNullOrEmpty(request.Status))
        {
            conditions.Add("o.status = @Status");
            parameters.Add("@Status", request.Status);
        }

        var whereClause = conditions.Count > 0
            ? "WHERE " + string.Join(" AND ", conditions)
            : "";

        parameters.Add("@Offset", (request.Page - 1) * request.PageSize);
        parameters.Add("@Limit", request.PageSize);

        var sql = $@"
            SELECT
                o.id,
                c.name  AS CustomerName,
                COUNT(ol.id) AS LineCount,
                o.total,
                o.status,
                o.ordered_at
            FROM orders o
            INNER JOIN customers c ON c.id = o.customer_id
            LEFT JOIN order_lines ol ON ol.order_id = o.id
            {whereClause}
            GROUP BY o.id, c.name, o.total, o.status, o.ordered_at
            ORDER BY o.ordered_at DESC
            LIMIT @Limit OFFSET @Offset";

        var orders = await conn.QueryAsync<OrderSummaryDto>(sql, parameters);

        var total = await conn.ExecuteScalarAsync<int>(
            $"SELECT COUNT(*) FROM orders o {whereClause}", parameters);

        return new PagedResult<OrderSummaryDto>(orders.ToList(), total, request.Page, request.PageSize);
    }
}
```

<ExerciseBlock>
1. Implement CQRS for a product catalog: `CreateProductCommand`, `UpdateProductCommand`, `DeleteProductCommand`, `GetProductQuery`, and `ListProductsQuery`. Each as a separate handler class injecting `IDbConnectionFactory`. Wire them to Minimal API endpoints with MediatR.
2. Add a `ValidationBehavior` that validates commands using FluentValidation. Add a `PlaceOrderCommandValidator` that checks: `CustomerId > 0`, `Items` list is not empty, each item has `Quantity > 0` and `UnitPrice > 0`. The behavior should throw `ValidationException` with all failures if validation fails.
3. Write two handler implementations for `GetOrderQuery`: one using `QueryMultiple` (two queries) and one using a single JOIN with multi-mapping. Benchmark them with 10,000 orders in the database. Which is faster? Under what conditions would each be preferred?
</ExerciseBlock>
