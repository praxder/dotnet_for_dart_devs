---
title: "Dapper: Dynamic Queries with SqlBuilder"
day: 99
week: 20
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "building dynamic queries in Dart, filter objects"
csharpConcept: "Dapper SqlBuilder, dynamic WHERE, optional filters, search, pagination"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Dynamic queries — where filters, sorting, and pagination change based on user input — are common in any real API. Dapper's `SqlBuilder` class helps you compose these queries cleanly without string concatenation fragility.

## The Problem with Manual String Building

```csharp
// Manual approach: works, but fragile and hard to read
public async Task<IEnumerable<Product>> SearchAsync(ProductFilter f)
{
    var sql = "SELECT * FROM products WHERE 1=1";
    var parameters = new DynamicParameters();

    if (!string.IsNullOrWhiteSpace(f.Name))
    {
        sql += " AND name LIKE @Name";
        parameters.Add("@Name", $"%{f.Name}%");
    }
    if (f.CategoryId.HasValue)
    {
        sql += " AND category_id = @CategoryId";
        parameters.Add("@CategoryId", f.CategoryId);
    }
    // ... more conditions ...
    sql += " ORDER BY name LIMIT @Limit OFFSET @Offset";
    parameters.Add("@Limit", f.PageSize);
    parameters.Add("@Offset", (f.Page - 1) * f.PageSize);

    using var conn = Open();
    return await conn.QueryAsync<Product>(sql, parameters);
}
// This works but is fragile: extra spaces, wrong clause ordering, easy to mess up
```

## Dapper SqlBuilder

```csharp
// SqlBuilder composes SQL clauses cleanly
// Install: already included with Dapper
// using Dapper;  ← SqlBuilder is in the Dapper namespace

public async Task<IEnumerable<Product>> SearchAsync(ProductFilter filter)
{
    using var conn = factory.CreateConnection();

    var builder = new SqlBuilder();

    // Define the template — /**where**/ and /**orderby**/ are replaced by SqlBuilder
    var selector = builder.AddTemplate(@"
        SELECT id, name, price, category_id, stock_quantity, is_active
        FROM products
        /**where**/
        /**orderby**/
        LIMIT @PageSize OFFSET @Offset",
        new { filter.PageSize, Offset = (filter.Page - 1) * filter.PageSize });

    // Add clauses conditionally — SqlBuilder handles AND/WHERE automatically
    if (!string.IsNullOrWhiteSpace(filter.Name))
        builder.Where("name LIKE @Name", new { Name = $"%{filter.Name}%" });

    if (filter.CategoryId.HasValue)
        builder.Where("category_id = @CategoryId", new { filter.CategoryId });

    if (filter.MinPrice.HasValue)
        builder.Where("price >= @MinPrice", new { filter.MinPrice });

    if (filter.MaxPrice.HasValue)
        builder.Where("price <= @MaxPrice", new { filter.MaxPrice });

    if (filter.IsActive.HasValue)
        builder.Where("is_active = @IsActive", new { IsActive = filter.IsActive.Value ? 1 : 0 });

    // Whitelist sort column before adding it
    var allowedSorts = new HashSet<string> { "name", "price", "created_at" };
    var sortColumn = allowedSorts.Contains(filter.SortBy ?? "") ? filter.SortBy : "name";
    builder.OrderBy($"{sortColumn} {(filter.SortDescending ? "DESC" : "ASC")}");

    return await conn.QueryAsync<Product>(selector.RawSql, selector.Parameters);
}
```

## SqlBuilder — The Full API

```csharp
var builder = new SqlBuilder();

// /**where**/ → becomes WHERE clause (with proper AND joining)
builder.Where("status = @Status", new { Status = "Active" });
builder.Where("price > @Min", new { Min = 10m });
// Result: WHERE status = @Status AND price > @Min

// /**select**/ → custom SELECT columns
builder.Select("id, name, price");
builder.Select("category_id AS CategoryId");

// /**orderby**/ → ORDER BY clause
builder.OrderBy("name ASC");
builder.OrderBy("price DESC");
// Result: ORDER BY name ASC, price DESC

// /**join**/ → JOIN clauses
builder.Join("categories c ON c.id = p.category_id");
builder.LeftJoin("inventory i ON i.product_id = p.id");

// /**groupby**/ → GROUP BY clause
builder.GroupBy("category_id");

// /**having**/ → HAVING clause
builder.Having("COUNT(*) > @MinCount", new { MinCount = 5 });

// /**set**/ → SET clause (for UPDATE templates)
builder.Set("name = @Name", new { Name = "Updated" });
builder.Set("updated_at = @Now", new { Now = DateTime.UtcNow });
```

## Count Query with Same Filters

```csharp
// For pagination: run the same filters but count total rows
public async Task<(IEnumerable<Product> Items, int Total)> SearchWithCountAsync(ProductFilter filter)
{
    using var conn = factory.CreateConnection();

    var builder = new SqlBuilder();

    // Data query template
    var dataQuery = builder.AddTemplate(@"
        SELECT id, name, price, category_id
        FROM products
        /**where**/
        /**orderby**/
        LIMIT @PageSize OFFSET @Offset",
        new { filter.PageSize, Offset = (filter.Page - 1) * filter.PageSize });

    // Count query template — same builder, different template
    var countQuery = builder.AddTemplate(@"
        SELECT COUNT(*)
        FROM products
        /**where**/");

    // Add filters once — applied to both templates
    if (!string.IsNullOrWhiteSpace(filter.Name))
        builder.Where("name LIKE @Name", new { Name = $"%{filter.Name}%" });

    if (filter.CategoryId.HasValue)
        builder.Where("category_id = @CategoryId", new { filter.CategoryId });

    builder.OrderBy("name ASC");

    // Execute both in one QueryMultiple call:
    using var multi = await conn.QueryMultipleAsync(
        dataQuery.RawSql + "; " + countQuery.RawSql,
        dataQuery.Parameters);

    var items = await multi.ReadAsync<Product>();
    var total = await multi.ReadSingleAsync<int>();

    return (items, total);
}
```

## Full-Text Search Pattern

```csharp
// Simple LIKE-based search (works in any database)
public async Task<IEnumerable<Product>> FullTextSearchAsync(string searchTerm)
{
    using var conn = factory.CreateConnection();
    return await conn.QueryAsync<Product>(@"
        SELECT id, name, price, category_id,
               -- Relevance scoring: title match is more important
               CASE
                   WHEN name LIKE @ExactMatch THEN 3
                   WHEN name LIKE @StartsWith THEN 2
                   ELSE 1
               END AS Relevance
        FROM products
        WHERE name LIKE @Contains
           OR description LIKE @Contains
        ORDER BY Relevance DESC, name ASC
        LIMIT 50",
        new
        {
            ExactMatch = searchTerm,
            StartsWith = $"{searchTerm}%",
            Contains = $"%{searchTerm}%"
        });
}

// SQL Server FTS (Full-Text Search) via CONTAINS / FREETEXT:
var ftsResults = await conn.QueryAsync<Product>(@"
    SELECT id, name, price
    FROM products
    WHERE CONTAINS(name, @SearchTerm)
       OR FREETEXT(description, @SearchTerm)
    ORDER BY name",
    new { SearchTerm = searchTerm });
```

## Sorting — Whitelist Pattern

```csharp
// Safe dynamic sorting — validate the column, parameterize the direction
public static class SortableColumns
{
    // Map user-facing sort keys to actual SQL column expressions
    public static readonly Dictionary<string, string> Products = new(StringComparer.OrdinalIgnoreCase)
    {
        ["name"]         = "name",
        ["price"]        = "price",
        ["price_asc"]    = "price ASC",
        ["price_desc"]   = "price DESC",
        ["newest"]       = "created_at DESC",
        ["oldest"]       = "created_at ASC",
        ["stock"]        = "stock_quantity DESC",
    };
}

public async Task<IEnumerable<Product>> GetSortedAsync(string? sortKey, int limit)
{
    var orderExpr = SortableColumns.Products.GetValueOrDefault(sortKey ?? "", "name");

    using var conn = factory.CreateConnection();
    return await conn.QueryAsync<Product>(
        $"SELECT * FROM products WHERE is_active = 1 ORDER BY {orderExpr} LIMIT @Limit",
        new { Limit = limit });
    // orderExpr comes from your whitelist dictionary — not from user input directly
}
```

## Pagination Helper

```csharp
public record PageRequest(int Page = 1, int PageSize = 20)
{
    public int Offset => (Page - 1) * PageSize;
    public int Limit  => PageSize;
}

public record PagedResult<T>(
    IReadOnlyList<T> Items,
    int TotalCount,
    int Page,
    int PageSize)
{
    public int TotalPages => (int)Math.Ceiling((double)TotalCount / PageSize);
    public bool HasNextPage => Page < TotalPages;
    public bool HasPrevPage => Page > 1;
}
```

<ExerciseBlock>
1. Build a `CustomerSearchHandler` using `SqlBuilder` that supports: optional name search (LIKE), optional email search (LIKE), optional `isActive` filter, optional minimum order count filter (requires JOIN to orders), sortable by name or join date, and paginated. Return both the customer list and total count in one `QueryMultiple` call.
2. Add a relevance-scored product search endpoint `GET /api/products/search?q=...` that returns up to 50 results ranked by: exact name match (3 pts), name starts with (2 pts), name contains (1 pts), description contains (1 pt). Map results to `ProductSearchResultDto` with a `Relevance` field.
3. Write a test that verifies SQL injection is impossible with your `SearchAsync` method. Pass `"'; DROP TABLE products; --"` as the search name filter. Verify: no exception, products table still exists, the malicious string was treated as a literal search term.
</ExerciseBlock>
