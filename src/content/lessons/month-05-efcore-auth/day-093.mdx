---
title: "Dapper: Parameters and SQL Safety"
day: 93
week: 19
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "sqflite parameterized queries, SQL injection prevention"
csharpConcept: "DynamicParameters, IN clauses, DbType, SQL injection prevention, parameterized queries"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Since you write SQL with Dapper, SQL injection is entirely your responsibility. The good news: Dapper's parameter system makes it easy to stay safe. The risk comes only when you concatenate strings into SQL instead of using parameters.

## SQL Injection: The Only Real Danger with Dapper

```csharp
// ❌ NEVER DO THIS — string concatenation = SQL injection
var name = request.Name;  // attacker sends: "' OR 1=1; DROP TABLE products; --"
var products = await conn.QueryAsync<Product>(
    $"SELECT * FROM products WHERE name = '{name}'");  // DANGEROUS

// ✅ ALWAYS USE PARAMETERS — Dapper sends the value separately from the SQL
var products = await conn.QueryAsync<Product>(
    "SELECT * FROM products WHERE name = @Name",
    new { Name = name });
// The driver sends: SELECT * FROM products WHERE name = ?
// And separately: parameter value = "' OR 1=1; DROP TABLE products; --"
// SQL injection impossible — the value is never interpreted as SQL
```

<ConceptCallout type="gotcha" title="String Interpolation in SQL = Injection Risk">
Never use `$"... {variable} ..."` to build SQL strings. Always use `@ParameterName` placeholders and pass the values separately. This applies even for "safe" values like integers — build the habit of always parameterizing.
</ConceptCallout>

## DynamicParameters — Full Control Over Parameters

```csharp
// DynamicParameters lets you specify DbType, size, direction
var parameters = new DynamicParameters();

parameters.Add("@Name", "Widget", DbType.String, size: 200);
parameters.Add("@Price", 9.99m, DbType.Decimal);
parameters.Add("@CategoryId", 3, DbType.Int32);
parameters.Add("@CreatedAt", DateTime.UtcNow, DbType.DateTime2);

await conn.ExecuteAsync(
    "INSERT INTO products (name, price, category_id, created_at) VALUES (@Name, @Price, @CategoryId, @CreatedAt)",
    parameters);

// Add from existing object AND override specific values:
var product = new Product { Name = "Widget", Price = 9.99m, CategoryId = 3 };
var dp = new DynamicParameters(product);     // adds all matching properties
dp.Add("@Timestamp", DateTime.UtcNow);       // add extra parameters

await conn.ExecuteAsync("INSERT ...", dp);
```

## Output Parameters (Stored Procedures)

```csharp
// Stored procedure with output parameter
var parameters = new DynamicParameters();
parameters.Add("@CustomerId", 42, DbType.Int32);
parameters.Add("@TotalOrders", dbType: DbType.Int32, direction: ParameterDirection.Output);
parameters.Add("@TotalSpent",  dbType: DbType.Decimal, direction: ParameterDirection.Output);

await conn.ExecuteAsync(
    "sp_GetCustomerSummary",
    parameters,
    commandType: CommandType.StoredProcedure);

// Read the output values after execution:
int totalOrders = parameters.Get<int>("@TotalOrders");
decimal totalSpent = parameters.Get<decimal>("@TotalSpent");
```

## IN Clauses — Querying Multiple Values

```csharp
// Dapper handles IEnumerable parameters for IN clauses automatically
var ids = new[] { 1, 2, 3, 4, 5 };

var products = await conn.QueryAsync<Product>(
    "SELECT * FROM products WHERE id IN @Ids",
    new { Ids = ids });
// Dapper generates: WHERE id IN (@Ids1, @Ids2, @Ids3, @Ids4, @Ids5)
// Each value becomes a separate parameter — fully safe

// Works with any IEnumerable
var statuses = new List<string> { "Pending", "Processing" };
var orders = await conn.QueryAsync<Order>(
    "SELECT * FROM orders WHERE status IN @Statuses",
    new { Statuses = statuses });

// IMPORTANT: empty list → invalid SQL ("WHERE id IN ()")
// Guard against empty collections:
if (!ids.Any())
    return Enumerable.Empty<Product>();

var products = await conn.QueryAsync<Product>(
    "SELECT * FROM products WHERE id IN @Ids",
    new { Ids = ids });
```

<ConceptCallout type="gotcha" title="Empty IN Clause">
Passing an empty array to an `IN @Param` clause generates invalid SQL. Always check `if (!list.Any()) return empty result` before executing the query. This is a common Dapper gotcha.
</ConceptCallout>

## Building Safe Dynamic WHERE Clauses

```csharp
// Problem: you need optional filters but can't concatenate strings
// Solution: build the WHERE clause with string concatenation on the SQL STRUCTURE,
//           but always keep the VALUES as parameters

public async Task<IEnumerable<Product>> SearchAsync(ProductFilter filter)
{
    using var conn = Open();

    // Build the SQL structure (not the values)
    var conditions = new List<string> { "1 = 1" };  // always-true base
    var parameters = new DynamicParameters();

    if (!string.IsNullOrWhiteSpace(filter.Name))
    {
        conditions.Add("name LIKE @Name");
        parameters.Add("@Name", $"%{filter.Name}%");  // value is parameterized
    }

    if (filter.CategoryId.HasValue)
    {
        conditions.Add("category_id = @CategoryId");
        parameters.Add("@CategoryId", filter.CategoryId.Value);
    }

    if (filter.MinPrice.HasValue)
    {
        conditions.Add("price >= @MinPrice");
        parameters.Add("@MinPrice", filter.MinPrice.Value);
    }

    if (filter.MaxPrice.HasValue)
    {
        conditions.Add("price <= @MaxPrice");
        parameters.Add("@MaxPrice", filter.MaxPrice.Value);
    }

    if (filter.IsActive.HasValue)
    {
        conditions.Add("is_active = @IsActive");
        parameters.Add("@IsActive", filter.IsActive.Value ? 1 : 0);
    }

    // The ORDER BY column is part of SQL structure — validate against whitelist
    var allowedSorts = new HashSet<string> { "name", "price", "created_at" };
    var sortColumn = allowedSorts.Contains(filter.SortBy ?? "") ? filter.SortBy : "name";
    var sortDirection = filter.SortDescending ? "DESC" : "ASC";

    var sql = $@"
        SELECT id, name, price, category_id, is_active
        FROM products
        WHERE {string.Join(" AND ", conditions)}
        ORDER BY {sortColumn} {sortDirection}   -- safe: whitelist validated
        LIMIT @PageSize OFFSET @Offset";

    parameters.Add("@PageSize", filter.PageSize);
    parameters.Add("@Offset", (filter.Page - 1) * filter.PageSize);

    return await conn.QueryAsync<Product>(sql, parameters);
}
```

## Column Names and ORDER BY — Safe Dynamic SQL

```csharp
// ORDER BY cannot be parameterized — must be validated against a whitelist
// This is a real Dapper limitation (and a SQL limitation)

// ❌ Wrong: parameters don't work for column names
await conn.QueryAsync<Product>(
    "SELECT * FROM products ORDER BY @SortColumn",  // will NOT work as intended
    new { SortColumn = "price" });
// This parameterizes the string "price" as a VALUE, not a column name

// ✅ Correct: whitelist and interpolate the structure (not user data)
private static readonly HashSet<string> ValidSortColumns =
    new(StringComparer.OrdinalIgnoreCase)
    { "name", "price", "created_at", "category_id" };

string sortCol = ValidSortColumns.Contains(request.SortBy)
    ? request.SortBy       // safe: confirmed to be a known column name
    : "name";              // default

var sql = $"SELECT * FROM products ORDER BY {sortCol} DESC";
// The column name comes from your whitelist, not from user input
```

## Null Parameters

```csharp
// Nullable values work naturally with DynamicParameters
var parameters = new DynamicParameters();
parameters.Add("@Phone", customer.Phone, DbType.String);
// If customer.Phone is null, sends NULL to the database — correct behavior

// With anonymous objects: nulls also work
await conn.ExecuteAsync(
    "UPDATE customers SET phone = @Phone WHERE id = @Id",
    new { Phone = customer.Phone, Id = customer.Id });
// If Phone is null → sets the column to NULL in the database

// Reading nullable columns:
public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; } = "";
    public string? Phone { get; set; }  // nullable: maps to NULL in DB
    public DateTime? LastLoginAt { get; set; }
}
```

## Pattern: Validate Before Querying

```csharp
// Input validation belongs in the service layer, not the repository
// But Dapper makes it easy to ensure parameters are sane

public async Task<Customer?> GetByEmailAsync(string email)
{
    // Validate at the boundary — before touching the database
    if (string.IsNullOrWhiteSpace(email))
        throw new ArgumentException("Email cannot be empty", nameof(email));

    email = email.Trim().ToLowerInvariant();

    using var conn = Open();
    return await conn.QueryFirstOrDefaultAsync<Customer>(
        "SELECT * FROM customers WHERE LOWER(email) = @Email",
        new { Email = email });
}
```

<ExerciseBlock>
1. Write a `SearchOrdersAsync` method that accepts: optional customer ID, optional status (string), optional date range (from/to), optional minimum total — all nullable. Build the WHERE clause dynamically using DynamicParameters. Verify via SQL logging that each combination generates correct parameterized SQL.
2. Create a `GetProductsByIdsAsync(IEnumerable<int> ids)` method. Add the empty-list guard. Test with: empty list (should return empty immediately), single ID, and 20 IDs.
3. Security exercise: write a test that passes a SQL injection string as a filter name (e.g., `"'; DROP TABLE products; --"`). Verify the query executes safely (no error, no table dropped) by checking the products table still has its data after the call.
</ExerciseBlock>
