---
title: "Dapper: Testing — Integration Tests with Real Databases"
day: 104
week: 21
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "integration testing in Flutter, test databases in sqflite"
csharpConcept: "TestContainers, SQLite in-memory, database fixtures, repository integration tests, xUnit"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Since Dapper doesn't abstract the database as much as EF Core, integration tests against a real database are especially valuable. You want to verify that your SQL is correct, your type mappings work, and your repositories do what they claim.

## Test Strategies with Dapper

| Strategy | Speed | Fidelity | Use When |
|---|---|---|---|
| Fake repository | Fastest | None | Pure unit tests of service logic |
| SQLite in-memory | Fast | Medium | Most integration tests |
| Real DB via TestContainers | Slower | High | Critical paths, production parity |

## SQLite In-Memory Database

```csharp
// SQLite in-memory: the fastest real database for tests
// Create a shared connection — the in-memory DB lives as long as the connection is open

public class SqliteTestDatabase : IAsyncDisposable
{
    private readonly SqliteConnection _conn;

    private SqliteTestDatabase(SqliteConnection conn) => _conn = conn;

    public static async Task<SqliteTestDatabase> CreateAsync()
    {
        var conn = new SqliteConnection("Data Source=:memory:");
        await conn.OpenAsync();  // must stay open to keep the in-memory DB alive

        // Run schema setup
        await conn.ExecuteAsync(@"
            CREATE TABLE products (
                id           INTEGER PRIMARY KEY AUTOINCREMENT,
                name         TEXT NOT NULL,
                price        REAL NOT NULL,
                category_id  INTEGER NOT NULL,
                stock_qty    INTEGER NOT NULL DEFAULT 0,
                is_active    INTEGER NOT NULL DEFAULT 1
            );

            CREATE TABLE categories (
                id   INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL
            );");

        return new SqliteTestDatabase(conn);
    }

    // Return the connection for use in repositories
    public IDbConnection Connection => _conn;

    // Get a factory that always returns this connection
    public IDbConnectionFactory Factory => new FixedConnectionFactory(_conn);

    // Helper: insert test data
    public async Task SeedAsync(params object[] products)
    {
        await _conn.ExecuteAsync(
            "INSERT INTO products (name, price, category_id, is_active) VALUES (@Name, @Price, @CategoryId, 1)",
            products);
    }

    // Reset between tests
    public async Task ResetAsync()
    {
        await _conn.ExecuteAsync("DELETE FROM products; DELETE FROM categories;");
    }

    public async ValueTask DisposeAsync()
    {
        await _conn.CloseAsync();
        _conn.Dispose();
    }
}

// Fixed factory: always returns the same connection (for tests)
public class FixedConnectionFactory(IDbConnection conn) : IDbConnectionFactory
{
    public IDbConnection CreateConnection() => conn;
    public Task<IDbConnection> CreateOpenConnectionAsync(CancellationToken ct = default)
        => Task.FromResult(conn);
}
```

## xUnit Test Fixtures — Shared Database

```csharp
// DatabaseFixture: shared across tests in a class (IClassFixture)
// or across multiple classes (ICollectionFixture)

public class DatabaseFixture : IAsyncLifetime
{
    public SqliteTestDatabase Db { get; private set; } = null!;

    public async Task InitializeAsync()
    {
        Db = await SqliteTestDatabase.CreateAsync();
    }

    public async Task DisposeAsync()
    {
        await Db.DisposeAsync();
    }
}

[Collection("Database")]
public class ProductRepositoryTests(DatabaseFixture fixture) : IAsyncLifetime
{
    private readonly IProductRepository _repo =
        new ProductRepository(fixture.Db.Factory);

    // Reset data before each test
    public Task InitializeAsync() => fixture.Db.ResetAsync();
    public Task DisposeAsync() => Task.CompletedTask;

    [Fact]
    public async Task GetByIdAsync_ReturnsProduct_WhenExists()
    {
        // Arrange
        await fixture.Db.SeedAsync(new { Name = "Widget", Price = 9.99, CategoryId = 1 });
        var all = await _repo.GetAllAsync();
        var id = all.First().Id;

        // Act
        var product = await _repo.GetByIdAsync(id);

        // Assert
        Assert.NotNull(product);
        Assert.Equal("Widget", product.Name);
        Assert.Equal(9.99m, product.Price);
    }

    [Fact]
    public async Task GetByIdAsync_ReturnsNull_WhenNotFound()
    {
        var result = await _repo.GetByIdAsync(99999);
        Assert.Null(result);
    }

    [Fact]
    public async Task CreateAsync_ReturnsNewId()
    {
        var product = new Product { Name = "Gadget", Price = 29.99m, CategoryId = 1 };
        var id = await _repo.CreateAsync(product);

        Assert.True(id > 0);

        var fetched = await _repo.GetByIdAsync(id);
        Assert.NotNull(fetched);
        Assert.Equal("Gadget", fetched.Name);
    }

    [Fact]
    public async Task DeleteAsync_RemovesProduct()
    {
        await fixture.Db.SeedAsync(new { Name = "ToDelete", Price = 1m, CategoryId = 1 });
        var id = (await _repo.GetAllAsync()).First().Id;

        var deleted = await _repo.DeleteAsync(id);
        Assert.True(deleted);

        var after = await _repo.GetByIdAsync(id);
        Assert.Null(after);
    }
}
```

## TestContainers — Production Database Parity

```csharp
// For SQL Server / PostgreSQL specific SQL, use a real containerized DB
// dotnet add package Testcontainers.SqlServer
// dotnet add package Testcontainers.PostgreSql
// Requires Docker installed on the CI runner

public class SqlServerDatabaseFixture : IAsyncLifetime
{
    private readonly MsSqlContainer _container = new MsSqlBuilder()
        .WithImage("mcr.microsoft.com/mssql/server:2022-latest")
        .WithPassword("Your_Strong!Passw0rd")
        .Build();

    public string ConnectionString => _container.GetConnectionString();
    public IDbConnectionFactory Factory => new SqlServerConnectionFactory(ConnectionString);

    public async Task InitializeAsync()
    {
        await _container.StartAsync();

        // Run schema migrations
        using var conn = Factory.CreateConnection();
        await conn.ExecuteAsync(@"
            CREATE TABLE products (
                id           INT IDENTITY(1,1) PRIMARY KEY,
                name         NVARCHAR(200) NOT NULL,
                price        DECIMAL(18,2) NOT NULL,
                category_id  INT NOT NULL,
                is_active    BIT NOT NULL DEFAULT 1
            );");
    }

    public Task DisposeAsync() => _container.DisposeAsync().AsTask();
}

// Test class using the real SQL Server container:
public class ProductRepositoryIntegrationTests(SqlServerDatabaseFixture fixture)
    : IClassFixture<SqlServerDatabaseFixture>
{
    [Fact]
    public async Task Insert_And_Query_RoundTrip()
    {
        var repo = new ProductRepository(fixture.Factory);

        var id = await repo.CreateAsync(new Product
        {
            Name = "SQL Server Widget",
            Price = 99.99m,
            CategoryId = 1
        });

        var product = await repo.GetByIdAsync(id);
        Assert.Equal("SQL Server Widget", product?.Name);
    }
}
```

## Testing Transactions

```csharp
[Fact]
public async Task PlaceOrder_RollsBack_OnInsufficientStock()
{
    // Arrange: product with 2 units in stock
    await fixture.Db.SeedAsync(
        new { Name = "Limited Widget", Price = 10m, CategoryId = 1, StockQty = 2 });
    var productId = (await _productRepo.GetAllAsync()).First().Id;

    var service = new OrderService(
        new ProductRepository(fixture.Db.Factory),
        new OrderRepository(fixture.Db.Factory));

    // Act & Assert: try to order 5 units (should fail)
    await Assert.ThrowsAsync<InsufficientStockException>(() =>
        service.PlaceOrderAsync(new PlaceOrderRequest
        {
            CustomerId = 1,
            Items = [new OrderItem { ProductId = productId, Quantity = 5, UnitPrice = 10m }]
        }));

    // Verify: stock unchanged (transaction rolled back)
    var product = await _productRepo.GetByIdAsync(productId);
    Assert.Equal(2, product!.StockQuantity);

    // Verify: no order was created
    var orders = await _orderRepo.GetByCustomerAsync(1);
    Assert.Empty(orders);
}
```

## API Integration Tests with WebApplicationFactory

```csharp
// Test the full HTTP pipeline against a test database
public class BlogApiTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;

    public BlogApiTests(WebApplicationFactory<Program> factory)
    {
        _client = factory
            .WithWebHostBuilder(builder =>
            {
                builder.ConfigureServices(services =>
                {
                    // Replace the real connection factory with test SQLite
                    services.AddSingleton<IDbConnectionFactory>(
                        new SqliteConnectionFactory("Data Source=:memory:;Cache=Shared"));
                });
            })
            .CreateClient();
    }

    [Fact]
    public async Task GetProduct_Returns404_WhenNotFound()
    {
        var response = await _client.GetAsync("/api/products/99999");
        Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
    }

    [Fact]
    public async Task CreateAndGetProduct_RoundTrip()
    {
        // Create
        var createResponse = await _client.PostAsJsonAsync("/api/products", new
        {
            Name = "Test Product",
            Price = 29.99,
            CategoryId = 1
        });
        createResponse.EnsureSuccessStatusCode();
        var created = await createResponse.Content.ReadFromJsonAsync<ProductDto>();

        // Get
        var getResponse = await _client.GetAsync($"/api/products/{created!.Id}");
        getResponse.EnsureSuccessStatusCode();
        var fetched = await getResponse.Content.ReadFromJsonAsync<ProductDto>();

        Assert.Equal("Test Product", fetched!.Name);
        Assert.Equal(29.99m, fetched.Price);
    }
}
```

<ExerciseBlock>
1. Set up a `DatabaseFixture` with SQLite in-memory for your `ProductRepository`. Write tests for every method: `GetByIdAsync`, `GetAllAsync`, `GetActiveByCategoryAsync`, `SearchAsync`, `CreateAsync`, `UpdateAsync`, `DeleteAsync`. Each test should reset the database and seed only the data it needs.
2. Write transaction integration tests for `OrderService.PlaceOrderAsync`: (a) success case verifies order created + stock decremented, (b) insufficient stock verifies both order and stock unchanged, (c) multi-item order verifies all stock reserved or all rolled back.
3. Add TestContainers tests for your most critical SQL queries — specifically any that use SQL Server-specific syntax (OUTPUT clause, MERGE, etc.). Verify they produce the same results as your SQLite versions for the shared SQL.
</ExerciseBlock>
