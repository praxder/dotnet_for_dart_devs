---
title: "Dapper: Getting Started"
day: 91
week: 19
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "sqflite — raw SQL in Dart"
csharpConcept: "Dapper, IDbConnection, QueryAsync<T>, ExecuteAsync, micro-ORM"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Dapper is a lightweight "micro-ORM" — it extends `IDbConnection` with helper methods that map SQL query results directly to C# objects. Unlike Entity Framework Core, Dapper doesn't generate SQL for you or manage migrations. You write the SQL; Dapper handles the tedious mapping from `IDataReader` rows to your classes.

This is exactly the tradeoff your company has chosen: full SQL control, zero magic, and performance that matches raw ADO.NET.

## Dapper vs EF Core: The Tradeoff

| | Dapper | EF Core |
|---|---|---|
| SQL | You write it | Generated from LINQ |
| Performance | Near-ADO.NET | Slightly more overhead |
| Learning curve | Know SQL → done | ORM concepts + LINQ |
| Complex queries | Natural | Can be awkward |
| Schema migration | You manage it | `dotnet ef migrations` |
| Flexibility | Maximum | Constrained to EF model |

<CodeComparison>
  <div slot="dart">
  ```dart
  // sqflite: you write raw SQL, map manually
  final db = await openDatabase('myapp.db');

  final results = await db.rawQuery(
    'SELECT * FROM products WHERE price < ?',
    [50.0],
  );

  final products = results
    .map((row) => Product.fromMap(row))
    .toList();
  ```
  </div>
  <div slot="csharp">
  ```csharp
  // Dapper: same idea — write SQL, map to C# objects automatically
  using var connection = new SqliteConnection(connectionString);

  var products = await connection.QueryAsync<Product>(
      "SELECT * FROM products WHERE price < @MaxPrice",
      new { MaxPrice = 50m });
  // Dapper maps column names → property names for you
  ```
  </div>
</CodeComparison>

## Installation

```bash
dotnet add package Dapper

# Plus a database driver — pick one:
dotnet add package Microsoft.Data.Sqlite       # SQLite
dotnet add package Microsoft.Data.SqlClient   # SQL Server
dotnet add package Npgsql                      # PostgreSQL
```

## Opening a Connection

```csharp
// Connection strings — store in appsettings.json, not in code
// appsettings.json:
{
  "ConnectionStrings": {
    "Default": "Data Source=myapp.db"
  }
}

// In Program.cs — register the connection string:
builder.Services.AddSingleton<IConfiguration>(builder.Configuration);

// In a repository or service — inject IConfiguration:
public class ProductRepository(IConfiguration config)
{
    private IDbConnection CreateConnection()
        => new SqliteConnection(config.GetConnectionString("Default"));
}
```

<ConceptCallout type="tip" title="Connection Lifetime with Dapper">
Unlike EF Core's `DbContext` (which you register as Scoped), Dapper works with raw connections. The pattern at most companies: create a connection per-method (open/close is fast thanks to connection pooling), or inject a connection factory. You'll see the factory pattern on day 101.
</ConceptCallout>

## Your First Query — QueryAsync&lt;T&gt;

```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = "";
    public decimal Price { get; set; }
    public int CategoryId { get; set; }
    public bool IsActive { get; set; }
}

public class ProductRepository(IConfiguration config)
{
    private IDbConnection Open()
        => new SqliteConnection(config.GetConnectionString("Default"));

    // QueryAsync<T>: returns IEnumerable<T>
    public async Task<IEnumerable<Product>> GetAllAsync()
    {
        using var conn = Open();
        return await conn.QueryAsync<Product>(
            "SELECT id, name, price, category_id, is_active FROM products");
    }

    // Single item — returns null if not found
    public async Task<Product?> GetByIdAsync(int id)
    {
        using var conn = Open();
        return await conn.QueryFirstOrDefaultAsync<Product>(
            "SELECT id, name, price, category_id, is_active FROM products WHERE id = @Id",
            new { Id = id });
    }
}
```

## Mapping: How Dapper Matches Columns to Properties

```csharp
// Dapper matches columns to properties case-insensitively
// "product_name" → ProductName (if you enable underscore mapping)
// "ProductName"  → ProductName (default: works as-is)

// Problem: SQL uses snake_case, C# uses PascalCase
// Column: category_id → Property: CategoryId
// Dapper handles this automatically for simple cases

// For snake_case databases (PostgreSQL, etc.) — enable globally:
DefaultTypeMap.MatchNamesWithUnderscores = true;
// Now: "category_id" maps to CategoryId, "is_active" maps to IsActive

// Or alias in SQL (always works):
var products = await conn.QueryAsync<Product>(@"
    SELECT
        id,
        name,
        price,
        category_id AS CategoryId,   -- explicit alias
        is_active   AS IsActive
    FROM products");
```

## Non-Query Operations — ExecuteAsync

```csharp
// INSERT
public async Task<int> InsertAsync(string name, decimal price, int categoryId)
{
    using var conn = Open();
    return await conn.ExecuteAsync(
        @"INSERT INTO products (name, price, category_id, is_active)
          VALUES (@Name, @Price, @CategoryId, 1)",
        new { Name = name, Price = price, CategoryId = categoryId });
    // Returns: rows affected (1 on success)
}

// UPDATE
public async Task<bool> UpdatePriceAsync(int id, decimal newPrice)
{
    using var conn = Open();
    var rowsAffected = await conn.ExecuteAsync(
        "UPDATE products SET price = @Price WHERE id = @Id",
        new { Price = newPrice, Id = id });
    return rowsAffected > 0;
}

// DELETE
public async Task<bool> DeleteAsync(int id)
{
    using var conn = Open();
    var rowsAffected = await conn.ExecuteAsync(
        "DELETE FROM products WHERE id = @Id",
        new { Id = id });
    return rowsAffected > 0;
}
```

## Getting the Inserted ID

```csharp
// SQL Server: use OUTPUT or SCOPE_IDENTITY()
public async Task<int> InsertAndGetIdAsync(Product product)
{
    using var conn = Open();

    // SQL Server:
    return await conn.QuerySingleAsync<int>(@"
        INSERT INTO products (name, price, category_id)
        OUTPUT INSERTED.id
        VALUES (@Name, @Price, @CategoryId)",
        product);

    // SQLite:
    // await conn.ExecuteAsync("INSERT INTO products ...", product);
    // return await conn.QuerySingleAsync<int>("SELECT last_insert_rowid()");

    // PostgreSQL:
    // return await conn.QuerySingleAsync<int>(
    //     "INSERT INTO products (name, price) VALUES (@Name, @Price) RETURNING id", product);
}
```

## Registering in DI

```csharp
// Program.cs — a simple approach: pass the connection string directly
// You'll learn the IDbConnectionFactory pattern on day 101

// For now, register repositories as Scoped:
builder.Services.AddScoped<ProductRepository>();
builder.Services.AddScoped<CustomerRepository>();
```

<ConceptCallout type="tip" title="Dapper is Just Extension Methods">
Dapper adds extension methods to `IDbConnection`. There's no `DbContext`, no change tracking, no migrations. Everything is explicit: you open a connection, execute a SQL string, get back objects. This makes the code extremely predictable — what you see is what runs.
</ConceptCallout>

<ExerciseBlock>
1. Create a `products` table with `id`, `name`, `price`, `category_id`, and `is_active` columns. Write a `ProductRepository` with `GetAllAsync()`, `GetByIdAsync(int id)`, `GetActiveByCategoryAsync(int categoryId)`, `InsertAsync(Product)`, `UpdatePriceAsync(int id, decimal price)`, and `DeleteAsync(int id)`. Test each method with Console.WriteLine output.
2. Enable `DefaultTypeMap.MatchNamesWithUnderscores = true` in Program.cs. Create a `categories` table with `id`, `name`, and `created_at` columns (snake_case). Write a `CategoryRepository` and verify that `created_at` maps to a `CreatedAt` DateTime property without SQL aliases.
3. Compare the approaches: write a query using Dapper and note the generated SQL (you write it). Then think about what EF Core would generate for the same query using `Include` and `Where`. What are the tradeoffs for your specific use case?
</ExerciseBlock>
