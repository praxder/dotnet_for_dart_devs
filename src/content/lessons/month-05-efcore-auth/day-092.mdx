---
title: "Dapper: CRUD Patterns"
day: 92
week: 19
module: 8
moduleName: "Dapper"
phase: "dotnet"
dartConcept: "sqflite insert/update/delete patterns"
csharpConcept: "QueryAsync, QueryFirstOrDefaultAsync, QuerySingleAsync, ExecuteAsync, QueryScalarAsync"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

With Dapper, CRUD is explicit: you write SQL, Dapper maps the results. Today you'll learn all the query methods Dapper provides and when to use each one.

## Reading Data — The Query Family

```csharp
using var conn = Open();

// QueryAsync<T> — 0 or more results (IEnumerable<T>)
var all = await conn.QueryAsync<Product>(
    "SELECT * FROM products WHERE is_active = 1");

// QueryFirstOrDefaultAsync<T> — first row or null
// Use this most often for "get by ID" queries
var product = await conn.QueryFirstOrDefaultAsync<Product>(
    "SELECT * FROM products WHERE id = @Id",
    new { Id = 42 });

// QuerySingleAsync<T> — exactly 1 row (throws if 0 or more than 1)
// Use when the query MUST return exactly one row
var count = await conn.QuerySingleAsync<int>(
    "SELECT COUNT(*) FROM products WHERE category_id = @CatId",
    new { CatId = 5 });

// QuerySingleOrDefaultAsync<T> — exactly 0 or 1 (throws if more than 1)
var user = await conn.QuerySingleOrDefaultAsync<User>(
    "SELECT * FROM users WHERE email = @Email",
    new { Email = "alice@example.com" });

// ExecuteScalarAsync<T> — single value (first column, first row)
var maxPrice = await conn.ExecuteScalarAsync<decimal?>(
    "SELECT MAX(price) FROM products WHERE category_id = @CatId",
    new { CatId = 5 });
```

<ConceptCallout type="tip" title="Choose the Right Query Method">
- `QueryAsync` → list of results (could be empty)
- `QueryFirstOrDefaultAsync` → get by ID, returns null if missing — **most common**
- `QuerySingleAsync` → scalar aggregates where the row must exist
- `QuerySingleOrDefaultAsync` → unique lookup that might not exist (e.g., by email)
- `ExecuteScalarAsync` → COUNT, MAX, SUM, EXISTS checks
</ConceptCallout>

## Full CRUD Repository Pattern

```csharp
public class CustomerRepository(IConfiguration config)
{
    private IDbConnection Open()
        => new SqliteConnection(config.GetConnectionString("Default"));

    // --- READ ---

    public async Task<IEnumerable<Customer>> GetAllAsync()
    {
        using var conn = Open();
        return await conn.QueryAsync<Customer>(
            "SELECT id, name, email, phone, created_at, is_active FROM customers");
    }

    public async Task<Customer?> GetByIdAsync(int id)
    {
        using var conn = Open();
        return await conn.QueryFirstOrDefaultAsync<Customer>(
            @"SELECT id, name, email, phone, created_at, is_active
              FROM customers
              WHERE id = @Id",
            new { Id = id });
    }

    public async Task<Customer?> GetByEmailAsync(string email)
    {
        using var conn = Open();
        return await conn.QuerySingleOrDefaultAsync<Customer>(
            "SELECT * FROM customers WHERE email = @Email",
            new { Email = email });
    }

    public async Task<IEnumerable<Customer>> GetActiveAsync()
    {
        using var conn = Open();
        return await conn.QueryAsync<Customer>(
            "SELECT * FROM customers WHERE is_active = 1 ORDER BY name");
    }

    // --- CREATE ---

    public async Task<int> CreateAsync(Customer customer)
    {
        using var conn = Open();
        // SQL Server: use OUTPUT INSERTED.id
        // SQLite: INSERT then SELECT last_insert_rowid()
        // PostgreSQL: RETURNING id
        return await conn.QuerySingleAsync<int>(@"
            INSERT INTO customers (name, email, phone, created_at, is_active)
            VALUES (@Name, @Email, @Phone, @CreatedAt, @IsActive);
            SELECT last_insert_rowid();",   // SQLite
            customer);
    }

    // --- UPDATE ---

    public async Task<bool> UpdateAsync(Customer customer)
    {
        using var conn = Open();
        var affected = await conn.ExecuteAsync(@"
            UPDATE customers
            SET name     = @Name,
                email    = @Email,
                phone    = @Phone,
                is_active = @IsActive
            WHERE id = @Id",
            customer);
        return affected > 0;
    }

    // Partial update — only change what you need
    public async Task<bool> DeactivateAsync(int id)
    {
        using var conn = Open();
        var affected = await conn.ExecuteAsync(
            "UPDATE customers SET is_active = 0 WHERE id = @Id",
            new { Id = id });
        return affected > 0;
    }

    // --- DELETE ---

    public async Task<bool> DeleteAsync(int id)
    {
        using var conn = Open();
        var affected = await conn.ExecuteAsync(
            "DELETE FROM customers WHERE id = @Id",
            new { Id = id });
        return affected > 0;
    }
}
```

## Passing Parameters — Multiple Ways

```csharp
// 1. Anonymous object (most common — clean and readable)
await conn.QueryAsync<Product>(
    "SELECT * FROM products WHERE category_id = @CatId AND price < @Max",
    new { CatId = 5, Max = 100m });

// 2. Your model directly (property names must match parameter names)
var product = new Product { Name = "Widget", Price = 9.99m, CategoryId = 3 };
await conn.ExecuteAsync(
    "INSERT INTO products (name, price, category_id) VALUES (@Name, @Price, @CategoryId)",
    product);

// 3. Dictionary (useful when building dynamic queries)
var parameters = new Dictionary<string, object>
{
    ["Name"] = "Widget",
    ["Price"] = 9.99m
};
await conn.ExecuteAsync(
    "INSERT INTO products (name, price) VALUES (@Name, @Price)",
    parameters);

// 4. DynamicParameters (most flexible — covered in depth on day 93)
var dp = new DynamicParameters();
dp.Add("@Name", "Widget");
dp.Add("@Price", 9.99m, DbType.Decimal, size: 18);
await conn.ExecuteAsync("INSERT INTO products (name, price) VALUES (@Name, @Price)", dp);
```

## Bulk Execute — ExecuteAsync with a List

```csharp
// Execute the same SQL once per item in a list
// Dapper handles the loop — not truly a bulk INSERT, but convenient
var newProducts = new List<Product>
{
    new() { Name = "Alpha", Price = 10m, CategoryId = 1 },
    new() { Name = "Beta",  Price = 20m, CategoryId = 1 },
    new() { Name = "Gamma", Price = 30m, CategoryId = 2 },
};

// ExecuteAsync with a list: runs INSERT 3 times (one per item)
await conn.ExecuteAsync(
    "INSERT INTO products (name, price, category_id) VALUES (@Name, @Price, @CategoryId)",
    newProducts);

// For true bulk insert performance, see day 102
```

## Checking Existence

```csharp
// EXISTS check — returns bool
public async Task<bool> EmailExistsAsync(string email)
{
    using var conn = Open();
    var count = await conn.ExecuteScalarAsync<int>(
        "SELECT COUNT(1) FROM customers WHERE email = @Email",
        new { Email = email });
    return count > 0;
}

// Or with EXISTS keyword (more efficient in SQL):
public async Task<bool> EmailExistsAsync(string email)
{
    using var conn = Open();
    return await conn.ExecuteScalarAsync<bool>(
        "SELECT EXISTS(SELECT 1 FROM customers WHERE email = @Email)",
        new { Email = email });
    // Works in PostgreSQL; for SQLite use CASE WHEN EXISTS ... THEN 1 ELSE 0 END
}
```

## Counting and Aggregates

```csharp
public class OrderStats
{
    public int CustomerId { get; set; }
    public int OrderCount { get; set; }
    public decimal TotalSpent { get; set; }
    public DateTime? LastOrderDate { get; set; }
}

public async Task<OrderStats?> GetCustomerStatsAsync(int customerId)
{
    using var conn = Open();
    return await conn.QueryFirstOrDefaultAsync<OrderStats>(@"
        SELECT
            @CustomerId AS CustomerId,
            COUNT(*)    AS OrderCount,
            COALESCE(SUM(total), 0) AS TotalSpent,
            MAX(ordered_at) AS LastOrderDate
        FROM orders
        WHERE customer_id = @CustomerId
          AND status != 'Cancelled'",
        new { CustomerId = customerId });
}
```

<ConceptCallout type="gotcha" title="QueryAsync Returns IEnumerable, Not List">
`QueryAsync` returns `IEnumerable<T>`, which is lazy. The data is already loaded from the database (unlike EF Core's `IQueryable`), but calling `.ToList()` gives you a concrete list you can index and iterate multiple times. If you only need to iterate once, keep it as `IEnumerable`. If you need `.Count` or multiple iterations, call `.ToList()`.
</ConceptCallout>

<ExerciseBlock>
1. Build a complete `OrderRepository` with: `GetAllAsync()`, `GetByIdAsync(int)`, `GetByCustomerAsync(int customerId)`, `GetByStatusAsync(string status)`, `CreateAsync(Order)` returning the new ID, `UpdateStatusAsync(int id, string status)`, and `DeleteAsync(int id)`. Use the appropriate query method for each.
2. Implement a `GetOrderSummaryAsync(int orderId)` that returns a custom `OrderSummaryDto` with: order ID, customer name (join), item count (subquery or join with COUNT), and total amount. Verify the SQL is a single query.
3. Write an `ExistsAsync(int id)` method for both `ProductRepository` and `OrderRepository`. Measure the difference between `SELECT COUNT(*) > 0` and `SELECT EXISTS(...)` using SQLite's query planner (`EXPLAIN QUERY PLAN`).
</ExerciseBlock>
