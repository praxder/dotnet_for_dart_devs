---
title: "Authorization: Policies, Roles, and Requirements"
day: 79
week: 16
module: 7
moduleName: "ASP.NET Core Fundamentals"
phase: "dotnet"
dartConcept: "Manual role checks, custom guard logic"
csharpConcept: "Policy-based auth, IAuthorizationRequirement, resource-based auth, [Authorize]"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Authentication answers "who are you?" — authorization answers "what can you do?" ASP.NET Core's policy-based authorization system lets you express complex business rules (not just role checks) in a reusable, testable way.

## The Three Levels of Authorization

```csharp
// Level 1: Simple [Authorize] — just requires authentication
[Authorize]
public IActionResult GetProfile() { ... }

// Level 2: Role-based
[Authorize(Roles = "Admin")]
public IActionResult GetAdminDashboard() { ... }

[Authorize(Roles = "Admin,Manager")]  // either role
public IActionResult GetReports() { ... }

// Level 3: Policy-based — most powerful and recommended
[Authorize(Policy = "PremiumUser")]
public IActionResult GetPremiumContent() { ... }
```

## Defining Authorization Policies

```csharp
// Program.cs
builder.Services.AddAuthorization(options =>
{
    // Simple claim check
    options.AddPolicy("PremiumUser", policy =>
        policy.RequireClaim("subscription_tier", "premium", "enterprise"));

    // Role + claim combination
    options.AddPolicy("ContentEditor", policy =>
        policy.RequireRole("Editor", "Admin")
              .RequireClaim("can_publish"));

    // Custom requirement
    options.AddPolicy("AccountOwner", policy =>
        policy.Requirements.Add(new AccountOwnerRequirement()));

    // Age check
    options.AddPolicy("Adult", policy =>
        policy.RequireAssertion(ctx =>
        {
            var claim = ctx.User.FindFirst("birthdate");
            return claim != null &&
                   DateTime.TryParse(claim.Value, out var dob) &&
                   (DateTime.Today - dob).TotalDays >= 365 * 18;
        }));

    // Authenticated only, no anonymous
    options.FallbackPolicy = new AuthorizationPolicyBuilder()
        .RequireAuthenticatedUser()
        .Build();
});
```

## Custom Requirements and Handlers

```csharp
// 1. Define the requirement (carries parameters)
public class MinimumOrdersRequirement : IAuthorizationRequirement
{
    public int MinimumOrders { get; }
    public MinimumOrdersRequirement(int min) => MinimumOrders = min;
}

// 2. Define the handler (evaluates the requirement)
public class MinimumOrdersHandler
    : AuthorizationHandler<MinimumOrdersRequirement>
{
    private readonly IOrderRepository _orders;

    public MinimumOrdersHandler(IOrderRepository orders) => _orders = orders;

    protected override async Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        MinimumOrdersRequirement requirement)
    {
        var userId = context.User.FindFirstValue(ClaimTypes.NameIdentifier);
        if (userId is null) return;  // not authenticated — don't succeed

        int orderCount = await _orders.GetCountForUserAsync(userId);

        if (orderCount >= requirement.MinimumOrders)
            context.Succeed(requirement);  // authorized!
        // else: fall through → not authorized (default)
    }
}

// 3. Register
builder.Services.AddScoped<IAuthorizationHandler, MinimumOrdersHandler>();
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("FrequentBuyer", policy =>
        policy.Requirements.Add(new MinimumOrdersRequirement(10)));
});
```

## Resource-Based Authorization

```csharp
// When the authorization decision depends on the resource being accessed
// (e.g., can this user edit THIS specific document?)

public class DocumentAuthorizationHandler
    : AuthorizationHandler<OperationAuthorizationRequirement, Document>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        OperationAuthorizationRequirement operation,
        Document resource)
    {
        var userId = context.User.FindFirstValue(ClaimTypes.NameIdentifier);
        var isAdmin = context.User.IsInRole("Admin");

        if (operation.Name == "Read" && (resource.IsPublic || resource.OwnerId == userId || isAdmin))
            context.Succeed(operation);

        if (operation.Name == "Write" && (resource.OwnerId == userId || isAdmin))
            context.Succeed(operation);

        if (operation.Name == "Delete" && isAdmin)
            context.Succeed(operation);

        return Task.CompletedTask;
    }
}

// Named operations (predefined constants)
public static class DocumentOperations
{
    public static readonly OperationAuthorizationRequirement Read = new() { Name = "Read" };
    public static readonly OperationAuthorizationRequirement Write = new() { Name = "Write" };
    public static readonly OperationAuthorizationRequirement Delete = new() { Name = "Delete" };
}

// Using resource-based auth in a controller
[HttpPut("{id:guid}")]
[Authorize]
public async Task<IActionResult> Update(Guid id, UpdateDocumentRequest request,
    [FromServices] IAuthorizationService authz)
{
    var doc = await _documents.GetByIdAsync(id);
    if (doc is null) return NotFound();

    var result = await authz.AuthorizeAsync(User, doc, DocumentOperations.Write);
    if (!result.Succeeded) return Forbid();

    await _documents.UpdateAsync(id, request);
    return NoContent();
}
```

## Authorization in Minimal APIs

```csharp
// Apply policies to Minimal API endpoints
app.MapGet("/premium", GetPremiumContent)
    .RequireAuthorization("PremiumUser");

app.MapDelete("/admin/users/{id}", DeleteUser)
    .RequireAuthorization("Admin");

app.MapGet("/health", GetHealth)
    .AllowAnonymous();  // explicitly opt out of fallback policy

// Group with shared policy
var adminGroup = app.MapGroup("/api/admin")
    .RequireAuthorization("Admin");

adminGroup.MapGet("/stats", GetStats);
adminGroup.MapGet("/users", GetAllUsers);
```

<ExerciseBlock>
1. Implement a `SubscriptionLevelRequirement` with levels `Free`, `Pro`, `Enterprise`. A `Pro` requirement is satisfied by Pro or Enterprise subscriptions. Wire up the policy and test all three subscription levels against a `Pro`-protected endpoint.
2. Build resource-based authorization for a blog: authors can edit their own posts, admins can edit any post. Use `IAuthorizationService.AuthorizeAsync` in the controller/endpoint.
3. Create an `[AuthorizePolicy("...", OrElse = "...")]` filter that succeeds if EITHER policy is satisfied (ASP.NET Core only supports AND by default). Implement it using a custom `IAuthorizationHandler` that combines two requirements with OR logic.
</ExerciseBlock>
