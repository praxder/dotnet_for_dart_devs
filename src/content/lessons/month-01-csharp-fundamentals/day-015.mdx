---
title: "ref, out, and in Parameters"
day: 15
week: 3
module: 2
moduleName: "Control Flow, Functions & Methods"
phase: "csharp"
dartConcept: "(no Dart equivalent — Dart passes all reference types by reference automatically)"
csharpConcept: "ref (pass by reference), out (output parameter), in (readonly reference)"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Dart has no equivalent for `ref`, `out`, or `in` parameter modifiers. These are C#-specific features that give you explicit control over how values are passed to methods — especially important for value types (structs, ints, etc.) where C# would otherwise copy the entire value.

## Why These Exist: Value Type Semantics

In Dart, everything is a reference — there's no concept of "passing by value" in the way C# does. In C#, value types (`int`, `double`, `struct`) are copied when passed to methods. These modifiers opt out of that behavior.

```csharp
// Without ref — value is COPIED
void DoubleIt(int n)
{
    n *= 2;  // modifies the local copy only
}

int x = 5;
DoubleIt(x);
Console.WriteLine(x);  // still 5 — original unchanged

// With ref — variable is passed by reference
void DoubleItRef(ref int n)
{
    n *= 2;  // modifies the ORIGINAL variable
}

int y = 5;
DoubleItRef(ref y);
Console.WriteLine(y);  // 10 — original changed!
```

## `ref` — Pass by Reference

`ref` makes a parameter an alias for the caller's variable. Changes inside the method affect the caller's variable. Must be initialized before passing.

```csharp
// Swapping two values — classic ref use case
void Swap<T>(ref T a, ref T b)
{
    var temp = a;
    a = b;
    b = temp;
}

int x = 1, y = 2;
Swap(ref x, ref y);
Console.WriteLine($"{x}, {y}"); // 2, 1

// Modifying a struct in place
void Translate(ref Point p, int dx, int dy)
{
    p = new Point(p.X + dx, p.Y + dy);
}

var point = new Point(10, 20);
Translate(ref point, 5, -3);
Console.WriteLine(point); // (15, 17)
```

<ConceptCallout type="tip" title="ref for Performance with Large Structs">
The main production use of `ref` is performance: passing a large `struct` by reference avoids copying hundreds of bytes. You'll see `ref` heavily in game development, numerical computing, and anywhere structs are large. For small value types, the overhead of tracking the reference often isn't worth it.
</ConceptCallout>

## `out` — Output Parameters

`out` is like `ref` but the parameter doesn't need to be initialized before the call, and **must** be assigned inside the method. The canonical use is the `TryParse` pattern — every `Try*` method in .NET uses `out`.

```csharp
// The TryParse pattern — you'll see this everywhere
if (int.TryParse("42", out int result))
{
    Console.WriteLine(result); // 42
}

// Declaring the out variable inline (C# 7+)
if (int.TryParse(userInput, out var n) && n > 0)
{
    ProcessPositiveNumber(n);
}

// If you don't care about the value, use discard _
if (int.TryParse(maybeNumber, out _))
{
    Console.WriteLine("It was a valid number");
}

// Writing your own TryParse-style method
bool TryParseColor(string hex, out Color color)
{
    color = default; // must initialize before any return
    if (hex is null || hex.Length != 7 || hex[0] != '#')
        return false;

    try
    {
        color = new Color(
            Convert.ToByte(hex[1..3], 16),
            Convert.ToByte(hex[3..5], 16),
            Convert.ToByte(hex[5..7], 16));
        return true;
    }
    catch
    {
        return false;
    }
}
```

<ConceptCallout type="different" title="out vs ref">

| | `ref` | `out` |
|---|---|---|
| Must be initialized before call? | Yes | No |
| Must be assigned inside method? | No | Yes |
| Primary use | Bidirectional pass | Return extra values (TryParse) |

</ConceptCallout>

### Multiple Return Values with `out`

Before tuples, `out` was the only way to return multiple values. Tuples are now preferred for new code, but you'll encounter `out` in the BCL constantly:

```csharp
// Old way — out parameters
void GetDimensions(Image img, out int width, out int height)
{
    width = img.PixelWidth;
    height = img.PixelHeight;
}
int w, h;
GetDimensions(image, out w, out h);

// Modern way — tuple return (preferred for new code)
(int Width, int Height) GetDimensions(Image img)
    => (img.PixelWidth, img.PixelHeight);

var (width, height) = GetDimensions(image);
```

## `in` — Readonly Reference (Performance Optimization)

`in` passes a value by reference but **prevents modification inside the method**. It's purely a performance optimization for large structs — you get the speed of pass-by-reference without accidentally mutating the caller's data.

```csharp
// Large struct — expensive to copy
public readonly struct Matrix4x4
{
    public readonly float M11, M12, M13, M14;
    public readonly float M21, M22, M23, M24;
    // ... 16 floats total
}

// Without 'in' — copies 64 bytes every call
float Trace(Matrix4x4 m) => m.M11 + m.M22 + m.M33 + m.M44;

// With 'in' — passes a reference (8 bytes), readonly inside
float Trace(in Matrix4x4 m) => m.M11 + m.M22 + m.M33 + m.M44;

var matrix = GetTransformMatrix();
float trace = Trace(in matrix); // caller explicitly opts in
// float trace = Trace(matrix); // also works, 'in' can be implicit at call site
```

<ConceptCallout type="tip">
For everyday application code, you rarely need `in`. It matters most in hot paths processing many large structs per frame/second — game engines, audio processing, financial math. When in doubt, don't use it and profile first.
</ConceptCallout>

## The Full Picture

```csharp
// Comprehensive example
public class Statistics
{
    // out: returns multiple computed values
    public static bool TryCalculate(
        IEnumerable<double> data,
        out double mean,
        out double stdDev)
    {
        mean = 0;
        stdDev = 0;

        var list = data.ToList();
        if (list.Count == 0) return false;

        mean = list.Average();
        var variance = list.Average(x => Math.Pow(x - mean, 2));
        stdDev = Math.Sqrt(variance);
        return true;
    }
}

// Usage
var values = new[] { 2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0 };
if (Statistics.TryCalculate(values, out var mean, out var stdDev))
{
    Console.WriteLine($"Mean: {mean:F2}, StdDev: {stdDev:F2}");
    // Mean: 5.00, StdDev: 2.00
}
```

<ExerciseBlock>
1. Implement a `Clamp(ref int value, int min, int max)` method that modifies the ref parameter in place to be within [min, max].
2. Write a `TryParseRange(string input, out int from, out int to)` method that parses "10-50" into two out integers, returning false if the format is wrong.
3. Create a `readonly struct Vector3` with X, Y, Z floats. Write a `Dot(in Vector3 a, in Vector3 b)` static method and compare how calling it feels vs calling without `in`.
</ExerciseBlock>
