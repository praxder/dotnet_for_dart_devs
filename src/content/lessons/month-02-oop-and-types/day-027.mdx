---
title: "Abstract Classes and sealed Classes"
day: 27
week: 6
module: 3
moduleName: "OOP — Classes, Structs & Records"
phase: "csharp"
dartConcept: "Dart abstract class, sealed class (Dart 3 — different semantics!)"
csharpConcept: "abstract class, sealed class (prevents inheritance — opposite of Dart!)"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Pay close attention here: `sealed` in C# means the **opposite** of what it means in Dart 3. This is one of the most surprising gotchas for Dart developers learning C#.

## `sealed` — The Critical Difference

<CodeComparison>
  <div slot="dart">
  ```dart
  // Dart sealed — allows subclassing WITHIN same library
  // Enables exhaustive pattern matching
  sealed class Shape {}
  class Circle extends Shape { double radius; }
  class Rectangle extends Shape { double w, h; }
  class Triangle extends Shape { double a, b, c; }

  // Exhaustive switch POSSIBLE because all subtypes are known
  String describe(Shape s) => switch (s) {
    Circle() => 'circle',
    Rectangle() => 'rect',
    Triangle() => 'triangle',
    // No _ needed — compiler knows all cases!
  };
  ```
  </div>
  <div slot="csharp">
  ```csharp
  // C# sealed — PREVENTS all inheritance (opposite of Dart!)
  public sealed class FinalClass
  {
      // Nobody can inherit from this
  }

  // This would be a COMPILE ERROR:
  // public class ChildClass : FinalClass { }

  // C# doesn't have Dart's sealed-for-exhaustive-matching concept built-in
  // The closest is abstract + internal subtypes, or using records

  // sealed on a method (different — prevents further override)
  public class Dog : Animal
  {
      public sealed override string Speak() => "Woof!";
  }
  ```
  </div>
</CodeComparison>

<ConceptCallout type="gotcha" title="sealed in C# = Cannot Inherit From It">
In C#, `sealed class` means **no subclassing allowed**. In Dart 3, `sealed class` means **subclassing allowed only within the same library, enabling exhaustive matching**. These are completely different semantics using the same keyword. C# sealed is closer to Dart's `final class`.
</ConceptCallout>

## When to Use `sealed` in C#

```csharp
// Use case 1: Singleton — prevent subclassing
public sealed class AppConfiguration
{
    public static AppConfiguration Instance { get; } = new();
    private AppConfiguration() {}
    public string ConnectionString { get; set; } = "";
}

// Use case 2: Performance — JIT can devirtualize calls
// sealed types allow the JIT to skip virtual dispatch
public sealed class FastStringBuilder { ... }

// Use case 3: Security — prevent inheritance-based attacks
public sealed class CryptographyKey
{
    private readonly byte[] _keyMaterial;
    // Sealing prevents a subclass from exposing _keyMaterial
}

// Use case 4: Value objects / DTOs
// Records are implicitly sealed (can't inherit from a record class)
public record Point(int X, int Y); // implicitly sealed
```

## `abstract` Classes — Same as Dart

`abstract` in C# works exactly like Dart's `abstract class`:

```csharp
// abstract class — cannot be instantiated
public abstract class Repository<T>
{
    // abstract method — must be implemented in subclass
    public abstract Task<T?> GetByIdAsync(int id);
    public abstract Task<IReadOnlyList<T>> GetAllAsync();
    public abstract Task SaveAsync(T entity);
    public abstract Task DeleteAsync(int id);

    // Non-abstract method — shared implementation
    public async Task<T> GetByIdOrThrowAsync(int id)
    {
        var entity = await GetByIdAsync(id);
        if (entity is null)
            throw new KeyNotFoundException($"{typeof(T).Name} {id} not found");
        return entity;
    }
}

// Concrete implementation
public class SqlUserRepository : Repository<User>
{
    private readonly AppDbContext _db;
    public SqlUserRepository(AppDbContext db) { _db = db; }

    public override async Task<User?> GetByIdAsync(int id)
        => await _db.Users.FindAsync(id);

    public override async Task<IReadOnlyList<User>> GetAllAsync()
        => await _db.Users.ToListAsync();

    public override async Task SaveAsync(User entity)
    {
        _db.Users.Add(entity);
        await _db.SaveChangesAsync();
    }

    public override async Task DeleteAsync(int id)
    {
        var user = await GetByIdAsync(id);
        if (user != null) _db.Users.Remove(user);
        await _db.SaveChangesAsync();
    }
}
```

## Achieving Dart's sealed Pattern in C#

To get exhaustive switch matching like Dart's `sealed` class, use one of these patterns:

```csharp
// Pattern 1: Abstract base with internal subtypes
// Place all in same file/namespace and don't expose constructor
public abstract class Shape
{
    private Shape() {}  // private constructor prevents external subclassing

    public sealed class Circle : Shape { public double Radius { get; init; } }
    public sealed class Rectangle : Shape { public double W { get; init; } public double H { get; init; } }
    public sealed class Triangle : Shape { public double A { get; init; } public double B { get; init; } public double C { get; init; } }
}

// Switch will warn if you miss a case (but needs default anyway — no true exhaustiveness)
Shape s = new Shape.Circle { Radius = 5 };
var area = s switch
{
    Shape.Circle c => Math.PI * c.Radius * c.Radius,
    Shape.Rectangle r => r.W * r.H,
    Shape.Triangle t => HeronsFormula(t.A, t.B, t.C),
    _ => throw new UnreachableException(), // compiler doesn't enforce exhaustiveness
};

// Pattern 2: Record hierarchy (cleaner)
public abstract record Shape2;
public record Circle2(double Radius) : Shape2;
public record Rectangle2(double W, double H) : Shape2;
```

<ConceptCallout type="info">
C# doesn't have true compile-time exhaustiveness checking for arbitrary class hierarchies. The best you can do is use the `_ => throw new UnreachableException()` catch-all to get a runtime error if you add a new subtype and forget to update a switch. Analyzers like Roslyn can add warnings for this.
</ConceptCallout>

<ExerciseBlock>
1. Create a `sealed class` `Money` with `Amount` (decimal) and `Currency` (string) that prevents subclassing. Implement operators for `+`, `-`, and comparison.
2. Build a `abstract class Notification` with abstract `Send()` and a concrete `LogNotification()` that all subclasses inherit. Create `EmailNotification`, `SmsNotification`, `PushNotification` subclasses. Seal the concrete subclasses.
3. Try to replicate Dart's `sealed` pattern for an `Event` type with three subtypes. Use nested private classes inside `Event` and a `switch` expression. Note what happens when you add a fourth event type and "forget" to handle it.
</ExerciseBlock>
