---
title: "Sorting, Comparing, and IComparable<T>"
day: 48
week: 10
module: 4
moduleName: "Collections, Generics & LINQ"
phase: "csharp"
dartConcept: "Comparable<T> mixin, Comparator function, List.sort()"
csharpConcept: "IComparable<T>, IComparer<T>, Comparer<T>.Create, Array.Sort, custom comparisons"
estimatedMinutes: 30
isProject: false
---

import ConceptCallout from '../../../components/lesson/ConceptCallout.astro';
import DartEquivalent from '../../../components/lesson/DartEquivalent.astro';
import CodeComparison from '../../../components/lesson/CodeComparison.astro';
import ExerciseBlock from '../../../components/lesson/ExerciseBlock.astro';

Sorting in C# has two mechanisms: `IComparable<T>` (the type defines its natural ordering) and `IComparer<T>` (external comparison logic). Knowing when to use each makes your types composable and your sorting code clean.

## IComparable\<T\> — Natural Ordering

<CodeComparison>
  <div slot="dart">
  ```dart
  // Dart: implement Comparable<T>
  class Temperature implements Comparable<Temperature> {
    final double celsius;
    const Temperature(this.celsius);

    @override
    int compareTo(Temperature other) =>
      celsius.compareTo(other.celsius);
  }

  final temps = [Temperature(25), Temperature(10), Temperature(30)];
  temps.sort();
  print(temps.map((t) => t.celsius)); // [10, 25, 30]
  ```
  </div>
  <div slot="csharp">
  ```csharp
  // C#: implement IComparable<T>
  public class Temperature : IComparable<Temperature>
  {
      public double Celsius { get; }
      public Temperature(double celsius) => Celsius = celsius;

      public int CompareTo(Temperature? other)
      {
          if (other is null) return 1;  // null sorts first by convention
          return Celsius.CompareTo(other.Celsius);
      }

      public override string ToString() => $"{Celsius}°C";
  }

  var temps = new[] { new Temperature(25), new Temperature(10), new Temperature(30) };
  Array.Sort(temps);  // uses IComparable<T>
  // [10°C, 25°C, 30°C]

  // Works with LINQ too
  var sorted = temps.Order().ToList();    // .NET 7+
  var min = temps.Min();
  var max = temps.Max();
  ```
  </div>
</CodeComparison>

## CompareTo Return Values

```csharp
// CompareTo convention:
// < 0  → this comes BEFORE other (this is smaller)
// = 0  → equal
// > 0  → this comes AFTER other (this is larger)

public int CompareTo(Priority? other)
{
    if (other is null) return 1;

    // Can delegate to existing CompareTo:
    return _value.CompareTo(other._value);

    // Or compute manually:
    if (_value < other._value) return -1;
    if (_value > other._value) return 1;
    return 0;
}
```

## IComparer\<T\> — External Comparison Logic

Use `IComparer<T>` when you need multiple sort orders, or when you can't modify the type:

```csharp
// Case-insensitive string comparison
IComparer<string> caseInsensitive = StringComparer.OrdinalIgnoreCase;

// Custom comparer for a type you don't control
IComparer<DateTime> byTime = Comparer<DateTime>.Create(
    (a, b) => a.TimeOfDay.CompareTo(b.TimeOfDay));

// Sort a list with a custom comparer
var products = GetProducts();

// By price descending
products.Sort(Comparer<Product>.Create((a, b) => b.Price.CompareTo(a.Price)));

// Or use LINQ — cleaner
var sortedByPrice = products.OrderByDescending(p => p.Price).ToList();
```

## Multi-Key Comparison

```csharp
public class Employee : IComparable<Employee>
{
    public string LastName { get; init; }
    public string FirstName { get; init; }
    public decimal Salary { get; init; }

    // Natural order: by last name, then first name
    public int CompareTo(Employee? other)
    {
        if (other is null) return 1;
        int lastNameCmp = string.Compare(LastName, other.LastName,
            StringComparison.OrdinalIgnoreCase);
        if (lastNameCmp != 0) return lastNameCmp;
        return string.Compare(FirstName, other.FirstName,
            StringComparison.OrdinalIgnoreCase);
    }
}

// Separate comparer for different sort order:
public class EmployeeBySalaryDesc : IComparer<Employee>
{
    public static readonly EmployeeBySalaryDesc Instance = new();

    public int Compare(Employee? x, Employee? y)
    {
        if (x is null && y is null) return 0;
        if (x is null) return -1;
        if (y is null) return 1;
        return y.Salary.CompareTo(x.Salary);  // descending
    }
}

// Usage
employees.Sort();                                    // uses IComparable — by name
employees.Sort(EmployeeBySalaryDesc.Instance);       // uses IComparer — by salary desc
var topEarners = employees.Order(EmployeeBySalaryDesc.Instance).Take(10);
```

## Sorting Strings Correctly

```csharp
// WRONG for user-visible text — ordinal comparison ignores culture
var wrong = names.OrderBy(n => n);  // ordinal, fine for code identifiers

// RIGHT for user display — culture-aware sort
var correct = names.OrderBy(n => n, StringComparer.CurrentCulture);

// Case-insensitive sort
var ciSort = names.OrderBy(n => n, StringComparer.OrdinalIgnoreCase);

// Natural sort ("file2" before "file10")
// No built-in — need a custom comparer
public class NaturalStringComparer : IComparer<string>
{
    public static readonly NaturalStringComparer Instance = new();

    public int Compare(string? x, string? y)
    {
        // Extract numeric parts and compare numerically
        // Full implementation would parse and compare segments
        return NaturalCompare(x ?? "", y ?? "");
    }
}
```

## Comparison Operators

```csharp
// Once you implement IComparable<T>, add comparison operators for completeness:
public static bool operator <(Temperature a, Temperature b)
    => a.CompareTo(b) < 0;
public static bool operator >(Temperature a, Temperature b)
    => a.CompareTo(b) > 0;
public static bool operator <=(Temperature a, Temperature b)
    => a.CompareTo(b) <= 0;
public static bool operator >=(Temperature a, Temperature b)
    => a.CompareTo(b) >= 0;
public static bool operator ==(Temperature a, Temperature b)
    => a.CompareTo(b) == 0;
public static bool operator !=(Temperature a, Temperature b)
    => a.CompareTo(b) != 0;
```

<ConceptCallout type="tip" title="Use record for Simple Value Objects">
If your type is a simple value object with natural ordering by a single property, consider using a `record struct` — it gets value equality for free. Add `IComparable<T>` manually only for the ordering.
</ConceptCallout>

<ExerciseBlock>
1. Implement a `Version` class that implements both `IComparable<Version>` and `IEquatable<Version>`, comparing `Major.Minor.Patch` correctly. Add all six comparison operators. Verify `new Version(1,10,0) > new Version(1,9,99)`.
2. Create a `MultiKeyComparer<T>` class that takes multiple `Comparison<T>` delegates in priority order and applies them sequentially (like `ThenBy` but for `Sort()`). Use it to sort products by category ascending, then price descending, then name ascending.
3. Write a `CaseInsensitiveNaturalSort` that sorts strings like a file explorer: case-insensitively, with embedded numbers sorted numerically ("file2" before "file10", "file10" before "file20").
</ExerciseBlock>
